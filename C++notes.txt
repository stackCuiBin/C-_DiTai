C到C++的升级

1，register关键字
	C++编译器有自己的优化方式
		C语言中无法获取register变量的地址
		C++中可以取得register变量的地址(优化方式是当去地址时，register关键字对变量的修饰失效)

2，在C语言中，重复定义多个同名的全局变量是合法的，多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。
	在C++中，不允许定义多个同名的全局变量

3, struct关键字的加强
	C语言中的struct定义了一组变量的集合，struct定义的标识符并不是一种新的类型；
	C++中的struct用于定义一个全新的类型

4，函数返回值及参数
   在C语言中
	int f()表示返回值为int，接受任意参数的函数
	f(void)表示返回值为int的无参函数
   在C++中
	int f()和int f(void)具有相同的意义
	表示返回值为int的无参函数
注：C++中所有的标识符都必须显示的声明类型，C语言中的默认类型在C++中是不合法的

第2课小结：
	C++更强调实用性，可以在任意的地方声明变量
	C++中的register只是一个兼容的作用
	C++编译器能够更好的进行优化
	C++中的任意标识符都必须显示的指明类型

5，const关键字
	C语言中的const：(1)修饰的变量是只读的，本质还是变量；(2)修饰的局部变量在栈上分配空间；
					(3)修饰的全局变量在只读存储区分配空间；(4)只在编译期有用，在运行期无用；
					(5)const修饰的变量不是真的常亮，它只是告诉编译器该变量不能出现在赋值符号的左边。
	C++中的const：C++在C的基础上对const进行了优化处理，当碰见const声明时在符号表中放入常量；
				  编译过程中若发现使用常量则以符号表中的值替换；
				  编译过程中若发现下述情况则给对应的常量分配存储空间，对const常量使用了extern，对const常量使用&操作符；
				  注意：C++编译器虽然可能为const常量分配空间，但不会使用其存储空间中的值。
	小结：C语言中的const变量是只读变量，会分配存储空间；
		  C++中的const变量可能分配存储空间：1)当const变量为全局，并且需要在其它文件中使用；2)当使用&操作符对const常量取地址。

	C++中const与宏定义
  	C++中的const常量类似于宏定义
		const int a = 5; 类似 #define a 5
	C++中的const常量早与宏定义不同
		const常量是由编译器处理
		编译器对const常量进行类型检查和作用域检查
		宏定义由预处理器处理，单纯的文本替换

第3课小结：
	与C语言不通，C++中的const不是只读变量
	C++中的const是一个真正意义上的常量
	C++编译器可能会为const常量分配空间(兼容C语言)
	C++完全兼容C语言中const常量的语法特性

6, bool类型
	C++中的bool类型
		C++在C语言的基本类型系统之上增加了bool
		C++中的bool可取的值只有true和false
		理论上bool只占用一个字节
		C++编译器会将非0值转换为true，0值转换为false

7，三目运算符
	C++对三目运算符进行了升级，可以作为左值，这句代码在C++中是正确的：(val_1 < val_2 ? val_1 : val_2) = 3;
	但是在C语言中是不可以作为左值的。

	C语言中的三目运算符返回的是变量值
		不能作为左值使用
	C++中的三目运算符可直接返回变量本身
		既可作为右值使用，又可作为左值使用
		注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用。
	C++对三目运算符做了什么？
		当三目运算符的可能返回都是变量时，返回的是变量的引用；
		当三目运算符的可能返回中有常量时，返回的是值。

8，C++中的引用
	变量名
		变量是一段实际连续存储空间的别名
		程序中通过变量来申请并命名存储空间
		通过变量名的名字可使用存储空间

	C++中新增了引用的概念
		引用可以看做一个已定义变量的别名
		引用的语法：Type& name = val;
		注意：普通引用在定义时必须用同类型的变量进行初始化

第4课小结：
	bool类型是C++新增加的基础类型
	bool类型的值只可能是true和false
	C++中的三目运算符可作为左值使用
	C++中的引用可以看做变量的别名来使用
	三目运算符的可能返回都是变量时，返回的是引用

9，const引用
	(1)在C++中可以声明const引用，const Type& name = val;
	const引用让变量拥有只读属性

	(2)当使用常量对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名
		const int&b = 1;	// OK
		int* p = (int *)&b;
		b = 5;				// error, 只读变量
		*p = 5;				// OK，修改变量的值
		结论：使用常量对const引用初始化后将生成一个只读变量！！！
		
  引用的本质
  	引用在C++中的内部实现是一个指针常量
		Type& name;		<--->		Type* const name;

		void f(int& a)				void f(int* const a)
		{				<--->		{
			a = 5;						*a = 5;
		}							}
	注意：C++编译器在编译过程中使用指针常量作为引用的内部实现，因此引用所占的空间大小与指针相同。
		  从使用的角度，引用只是一个别名，C++为了实用性而隐藏了引用的存储空间这一细节。

  引用的意义
  	C++中的引用旨在大多数的情况下代替指针
		功能性：可以满足多数需要使用指针的场合
		安全性：可以避开由于指针操作不当而带来的内存错误
		操作性：简单易用，又不失功能强大

第5课小结：
	引用作为变量别名而存在旨在代替指针
	const引用可以使得变量具有只读属性
	引用在编译器内部使用指针常量实现
	引用的最终本质为指针
	引用可以尽可能的避开内存错误(例如不要返回局部变量的引用)

10，内联函数
	C++中推荐使用内联函数代替宏代码片段
	C++中使用inline关键字声明内联函数
	内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求

	C++编译器可以将一个函数进行内联编译
	被C++编译器内联编译的函数叫做内联函数
	C++编译器直接将函数体插入到函数调用的地方
	内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)

	内联函数具有普通函数的特征(参数检查，返回类型等)
	函数的内敛请求可能被编译器拒绝
	函数被内联后，函数体直接扩展到调用的地方
	(宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程，因此可能出现副作用)

	现代C++编译器能够进行编译优化，一些函数即使没有inline声明，也可能被内联编译
	一些现代C++编译器提供了扩展语法，能够对函数进行强制内联，如：
		g++：  __attribute__((always_inline))属性
		MSVC： __forceinline

	注意事项：
	C++中inline内联编译的限制
		不能存在任何形式的循环语句
		不能存在过多的条件判断语句
		函数体不能过于庞大
		不能对函数进行取址操作
		函数内联声明必须在调用语句之前

第6课小结：
	C++中可以通过inline声明内联函数
	编译器直接将内联函数体扩展到函数调用的地方
	inline只是一种请求，编译器不一定允许这种请求
	内联函数省去了函数调用时压栈，跳转和返回的开销

11，函数参数的默认值
	C++中可以在函数声明时为参数提供一个默认值
	当函数调用时没有提供参数的值，则使用默认值
	参数的默认值必须在函数声明中指定

	函数默认参数的规则
		参数的默认值必须从右向左提供
		函数调用时使用了默认值，则后续参数必须使用默认值

	在C++中可以为函数提供占位参数
		占位参数只有参数类型声明，而没有参数名声明
		一般情况下，在函数体内部无法使用占位参数
	函数占位参数的意义
		占位参数与默认参数结合起来使用
		兼容C语言程序中可能出现的不规范写法

第7课小结：
	C++中支持函数参数的默认值
	如果函数调用时没有提供参数值，则使用默认值
	参数的默认值必须从右向左提供
	参数调用时使用了默认值，则后续参数必须使用默认值
	C++中支持占位参数，用于兼容C语言中的不规范写法

12，C++中的函数重载
	函数重载
		用同一个函数名定义不同的函数
		当函数名和不同的参数搭配时函数的含义不用

	函数重载至少满足下面的一个条件
		参数个数不同
		参数类型不同
		参数顺序不同

	编译器调用重载函数的准则
		将所有同名函数作为候选者
		尝试寻找可行的候选函数
			精确匹配参数
			通过默认参数能够匹配实参
			通过默认类型转换匹配实参
		匹配失败
			最终寻找到的候选函数不唯一，出现二义性，编译失败
			无法匹配所有候选者，函数未定义，编译失败。

	函数重载的注意事项
		重载函数早本质上是相互独立的不同函数
		重载函数的函数类型不同
		函数返回值不能作为函数重载的依据
		函数重载是由函数名和参数列表决定的

第8课小结：
	函数重载是C++中引入的概念
	函数重载用于模拟自然语言中的词汇搭配
	函数重载使得C++具有更丰富的语义表达能力
	函数重载的本质为相互独立的不同函数
	C++中通过函数名和函数参数确定函数调用

13，重载和指针
	函数重载遇上函数指针
		将重载函数名赋值给函数指针时
			根据重载规则挑选与函数指针参数列表一致的候选者
			严格匹配候选者的函数类型与函数指针的函数类型
	注意：函数重载必然发生在同一个作用域中
		  编译器需要用参数列表或函数类型进行函数选择
		  无法直接通过函数名得到重载函数的入口地址

	C++和C的相互调用
		实际工程中C++和C代码相互调用是不可避免的
		C++编译器能够兼容C语言的编译方式
		C++编译器会优先使用C++编译的方式
		extern 关键字能强制让C++编译器进行C方式的编译
			extern "C"
			{
			}

	如何保证一段C代码只会以C的方式被编译？
	解决方案：
		__cplusplus是C++编译器内置的标准宏定义
		__cplusplus的意义
			确保C代码以统一的C方式被编译成目标文件

	注意事项：
		C++编译器不能以C的方式编译重载函数
		编译方式决定函数名被编译后的目标名
			C++编译方式将函数名和参数列表编译成目标名
			C编译方式只将函数名作为目标名进行编译

第9课小结：
	函数重载是C++对C的一个重要升级
	函数重载通过函数参数列表区分不同的同名函数
	extern关键字能够实现C和C++的相互调用(extern中决不可存在重载函数)
	编译方式决定符号表中的函数名的最终目标名

14，动态内存分配
	C++中的动态内存分配
		C++中通过 new 关键字进行动态内存申请
		C++中的动态内存申请是基于类型进行的
		delete 关键字用于内存释放
		变量申请：
		Type× pointer = new Type;
		// ...
		delete pointer;
		数组申请：
		Type* pointer = new Type[N];
		// ...
		delete[] pointer;

	new 关键字与malloc函数的区别
		new 关键字是C++的一部分
		malloc是由C库提供的函数
		new以具体类型为单位进行内存分配
		malloc以字节为单位进行内存分配
		new在申请单个类型变量时可进行初始化
		malloc不具备内存初始化的特性

	new关键字的初始化
		int* pi = new int(1);
		float* pf = new float(2.0f);
		char* pc = new char('c');

15，C++中的命名空间
	在C语言中只有一个全局作用域
		C语言中所有的全局标识符共享同一个作用域
		标识符之间可能发生冲突
	C++中提出了命名空间的概念
		命名空间将全局作用域分成不同的部分
		不同命名空间中的标识符可以同名而不发生冲突
		命名空间可以相互嵌套
		全局作用域也叫默认命名空间
	C++命名空间的定义
		namespace Name
		{
			namespace Internal	// 嵌套
			{
				/* ... */
			}

			/* ... */
		}
	C++命名空间的使用
		使用整个命名空间：using namespace name;
		使用命名空间中的变量：using name::variable
		使用默认命名空间中的变量：::variable

第10课小结：
	C++中内置了动态内存分配的专用关键字
	C++中的动态内存分配可以同时进行初始化
	C++中的动态内存分配是基于类型进行的
	C++中的命名空间概念用于解决名称冲突问题

16，强制类型转换
	C方式强制类型转换存在问题
		过于粗暴
			任意类型之间都可以进行转换，编译器很难判断其正确性
		难于定位
			在源码中无法快速定位所有使用强制类型转换的语句

	C++将强制类型转换分为4种不同的类型	用法：xxx_cast< Type >( Expression )
		static_cast
			用于基本类型间的转换
			不能用于基本类型指针间的转换
			用于有继承关系类对象之间的转换和类指针之间的转换
		const_cast
			用于去除变量的只读属性
			强制转换的目标类型必须是指针或引用
		dynamic_cast
			用于有继承关系的类指针间的转换
			用于有交叉关系的类指针间的转换
			具有类型检查的功能
			需要虚函数的支持
		reinterpret_cast
			用于指针类型间的强制转换
			用于整数和指针类型间的强制转换

第11课小结：
	C方式的强制类型转换
		过于粗暴
		潜在的问题不易被发现
		不易在代码中定位
	新式类型转换以C++关键字的方式出现
		编译器能够帮助检查潜在的问题
		非常方便的在代码中定位
		支持动态类型识别( dynamic_cast )

17，经典问题剖析
	const常量的判别准则
		只有用字面量初始化的const常量才会进入符号表
		使用其它变量初始化的const常量仍然是只读变量
		被volatile修饰的const常量不会进入符号表
		在编译期间不能直接确定初始值的const标识符，都被作为只读变量处理
	const引用的类型与初始化变量的类型
		相同：初始化变量成为只读变量
		不同：生成一个新的只读变量

	指针是一个变量
		值为一个内存地址，不需要初始化，可以保存不同的地址
		通过指针可以访问对应内存地址中的值
		指针可以被const修饰为常量或者只读变量
	引用只是一个变量的新名字
		对引用的操作(赋值，取地址等)都会传递到代表的变量上
		const引用使其代表的变量具有只读属性
		引用必须在定义时初始化，之后无法代表其它变量
	从使用C++语言的角度来看
		引用与指针没有任何的关系
		引用是变量的新名字，操作引用就是操作对应的变量
	从C++编译器的角度来看
		为了支持新概念“引用”必须要有一个有效的解决方案
		在编译器内部，使用指针常量来实现“引用”
		因此“引用”在定义时必须初始化

第12课小结：
	指针是一个变量
	引用是一个变量的新名字
	const引用能够生成新的只读变量
	在编译器内部使用指针常量实现“引用”
	编译时不能直接确定初始值的const标识符都是只读变量
	C++不支持定义引用数组

18-1，面向对象的基本概念
	面向对象的意义
		将日常生活中习惯的思维方式引入程序设计中
		将需求中的概念直观的映射到解决方案中
		以模块为中心构建可复用的软件系统
		提高软件产品的可维护性和可扩展性

	类和对象是面向对象中的两个基本概念
		类：指的是一类事物，是一个抽象的概念
		对象：指的是属于某个类的具体实体
		类是一种模型，这种模型可以创建出不同的对象实体
		对象实体是类模型的一个具体实例
		一个类可以有很多对象，而一个对象必然属于某个类

第13课小结
	面向对象是当今软件开发中的重要方法
	类和对象是面向对象理论中的基本概念
	类和对象均来源于日常生活中
	每个类可以有多个对象
	每个对象必然属于某个类

18-2，面向对象基本概念
	类之间的基本关系
		继承
			从已存在类细分出来的类和原类之间具有继承关系( is-a )
			继承的类(子类)拥有原类(父类)的所有属性和行为
		组合
			一些类的存在必须依赖于其它的类，这种关系叫组合
			组合的类在某一局部上由其它的类组成

第14课小结
	类之间可以存在继承关系或组合关系
	继承关系中子类拥有父类的一切属性和行为
	组合关系是类之间整体和部分的关系
	类及类之间的关系可以有不同的表示法
	编译器对类的表示法有具体的要求

19，类的封装
	类通常分为以下两个部分
		类的实现细节
		类的使用方式
		当使用类时，不需要关心其实现细节
		当创建类时，才需要考虑其内部实现细节

	封装的基本概念
		根据经验：并不是类的每个属性都是对外公开的
				  而一些类的属性时对外公开的
				  必须在类的表示法中定义属性的行为的公开级别
				  	类似文件系统中的文件权限
	C++中类的封装
		成员变量：C++中用于表示类属性的变量
		成员函数：C++中用于表示类行为的函数
		C++中可以给成员变量和成员函数定义访问级别
			public
				成员变量和成员函数可以在类的内部和外界访问和调用
			private
				成员变量和成员函数只能在类的内部被访问和调用

	类成员的作用域
		类成员的作用域都只在类的内部，外部无法直接访问
		成员函数可以直接访问成员变量和调用成员函数
		类的外部可以通过类变量访问public成员
		类成员的作用域与访问级别没有关系
			C++中用struct定义的类中所有成员默认为public

第15课小结
	类通常可以分为使用方式和内部细节两部分
	类的封装机制使得使用方式和内部细节相分离
	C++中通过定义类成员的访问级别实现封装机制
	public成员可以在类的内部和外界访问和调用
	private成员只能在类的内部被访问和调用

20，类的真正形态
	类的关键字
		struct在C语言中已经有了自己的含义，必须继续兼容
		早C++中提供了新的关键字class用于类定义
		class和struct的用法是完全相同的
			不同点是什么？
			在用struct定义类时，所有成员的默认访问级别为public
			在用class定义类时，所有成员的默认访问级别为private

	C++中的类支持声明和实现的分离
	将类的实现和定义分开
		.h头文件中只有类的声明
			成员变量和成员函数的声明
		.cpp源文件中完成类的其它实现
			成员函数的具体实现

第16课小结
	C++引进了新的关键字class用于定义类
	struct和class的区别在于默认访问级别的不同
	C++中的类支持声明和实现的分离
		在头文件中声明类
		在原文件中实现类

21，对象的构造(上)
	从程序设计的角度，对象只是变量，因此：
		在栈上创建对象时，成员变量初始值为随机值
		在堆上创建对象时，成员变量初始值为随机值
		在静态存储区创建对象时，成员变量初始为0值

	构造函数
		C++中可以定义与类名相同的特殊成员函数
			这种特殊的成员函数叫做构造函数
				构造没有任何返回类型的声明
				构造函数在对象定义时自动被调用

第17课小结
	每个对象在使用之前都应该初始化
	类的构造函数用于对象的初始化
	构造函数与类同名并且没有返回值
	构造函数在对象定义时被自动被调用

22，对象的构造(中)
	构造函数
		带参数的构造函数
			构造函数可以根据需要定义参数
			一个类中可以存在多个重载的构造函数
			构造函数的重载遵循C++重载的规则
				class Test
				{
				public:
					Test() {}
					Test(int v) {}
				};

				int main()
				{
					Test t;			// Test()
					Test t1(1);		// Test(int v)
					Test t2 = 1;	// Test(int v)

					return 0;
				}

	友情提醒
		对象定义和对象声明不同
			对象定义：申请对象的空间并调用构造函数
			对象声明：告诉编器存在这样一个对象

	构造函数的调用
		一般情况下，构造韩顺在对象定义时被自动调用
		一些特殊情况下，需要手工调用构造函数

第18课小结
	构造函数可以根据需要定义参数
	构造函数之间可以存在重载关系
	构造函数遵循C++中重载函数的规则
	对象定义时会出发构造函数的调用
	在一些情况下可以手动调用构造函数

23，对象的构造(下)
	特殊的构造函数
		两个特殊的构造函数
			无参构造函数
				没有参数的构造函数
				当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空
			拷贝构造函数
				参数为const class_name& 的构造函数
				当类中没有定义拷贝构造函数时，编译器默认提供一个拷贝构造函数，简单的进行成员变量的值复制

	拷贝构造函数的意义
		兼容C语言的初始化方式
		初始化行为能够符合预期的逻辑
		浅拷贝
			拷贝后对象的物理状态相同
		深拷贝
			拷贝后对象的逻辑状态相同
		(编译器提供的拷贝构造函数只进行浅拷贝)

		什么时候需要进行深拷贝？
			对象中有成员指代了系统中的资源
				成员指向了动态内存空间
				成员开打了外存中的文件
				成员使用了系统中的网络端口
		
		一般性原则
			自定义拷贝构造函数，必然需要实现深拷贝

第19课小结
	C++编译器会默认提供构造函数
	无参构造函数用于定义对象的默认初始状态
	拷贝构造函数在创建对象时拷贝对象的状态
	对象的拷贝有浅拷贝和深拷贝两种方式
		浅拷贝使得对象的物理状态相同
		深拷贝使得对象的逻辑状态相同


24，初始化列表的使用
	类成员的初始化
		C++中提供了初始化列表对成员变量进行初始化
			语法规则
				Classname::ClassName() :
							m1(v1),m2(v1,v2),m3(v3)
				{
					// some other initialize operation
				}
	注意事项
		成员的初始化顺序与成员的声明顺序相同
		成员的初始化顺序与初始化列表中的位置无关
		初始化列表先于构造函数的函数体执行

	类中的const成员会被分配空间的(和类空间一致)
	类中的const成员的本质是只读变量
	类中的const成员只能在初始化列中指定初始值
	(编译器无法直接得到const成员的初始值，因此无法进入符号表成为真正意义上的常亮)

	初始化与赋值不同
		初始化：对正在创建的对象进行初值设置
		赋值：对已经存在的对象进行值设置

第20课小结
	类中可以使用初始化列表对成员进行初始化
	初始化列表先于构造函数体执行
	类中可以定义const成员变量
	const成员变量必须在初始化列表中指定初值
	const成员变量为只读变量


26，对象的构造顺序
	对于局部对象
		当程序执行流到达对象的定义语句时进行构造
			对象定义-> 构造
	对于堆对象
		当程序执行流到达new语句时创建对象
		使用new创建对象将自动触发构造函数的调用
	对于全局对象
		对象的构造顺序时不确定的
		不同的编译器使用不同的规则确定构造顺序

第21课小结
	局部对象的构造顺序依赖于程序的执行流
	堆对象的构造顺序依赖于new的使用顺序
	全局对象的构造顺序时不确定的

27，对象的销毁
	一般而言，需要销毁的对象都应该做清理
	解决方案：
		为每个类都提供一个public的free函数
		对象不在需要时立即调用free函数进行清理
	存在的问题
		free只是一个普通的函数，必须显示的调用
		对象销毁前没有做清理，很可能造成资源泄露

	C++的类中可以定义一个特殊的清理函数
		这个特殊的清理函数叫做析构函数
		析构函数的功能与构造函数相反
	定义：～ClassName()
		析构函数没有参数也没有返回值类型声明
		析构函数在对象销毁时自动被调用

	析构函数的定义准则
		当类中自定义了构造函数，并且构造函数中使用了系统资源(如：内存申请，文件打开等)，
		则需要自定义析构函数

第22课小结
	析构函数时对象销毁时进行清理的特殊函数
	析构函数在对象销毁时自动被调用
	析构函数时对象释放系统资源的保障

28，临时对象 
	构造函数是一个特殊的函数
		是否可以直接调用？
		是否可以在构造函数中调用构造函数？
		直接调用构造函数的行为是什么？
		答案：
			直接调用构造函数将会产生一个临时对象
			临时对象的生命周期只有一条语句的时间
			临时堆笑的作用域只在一条语句中
			临时对象的C++中值得警惕的灰色地带

第23课小结
	直接调用构造函数将产生一个临时对象
	临时对象是性能的瓶颈，也是bug的来源之一
	现在C++编译器会尽力避开临时对象
	实际工程开发中需要人为的避开临时对象

29，经典问题解析
	关于析构的疑问
		单个对象创建时构造函数的调用顺序
			1，调用父类的构造过程
			2，调用成员变量的构造函数(调用顺序与声明顺序相同)
			3，调用类自身的构造函数
				析构函数与对应构造函数的调用顺序相反

		多个对象析构时
			析构顺序与构造顺序相反

		对于栈对象和全局对象，类似于入栈与出栈的顺序，最后构造的对象最先析构

		堆对象的析构发生在使用delete的时候，与delete的使用顺序相关

	const关键字能否修饰类的对象？如果可以，有什么特性？
		const关键字能够修饰对象
		const修饰的对象为只读对象
		只读对象的成员变量不允许被改变
		只读对象是编译阶段的概念，运行时无效 
	C++中的const成员函数
		const对象只能调用const的成员函数
		const成员函数中只能调用const成员函数
		const成员函数中不能直接修改成员变量的值
	const成员函数的定义
		Type ClassName::function(Type p) const
		类中的函数声明与实际函数定义中都必须带const关键字

	成员函数和成员变量都是隶属于具体对象的吗？
		从面向对象的角度
			对象由属性(成员变量)和方法(成员函数)构成
		从程序运行的角度
			对象由数据和函数构成
				数据可以位于栈、堆和全局数据区
				函数只能位于代码段
	结论
		每一个对象拥有自己独立的属性(成员变量)
		所有的对象共享类的方法(成员函数)
		方法能够直接访问对象的属性
		方法中的隐藏参数 this 用于指代当前对象

第24课小结
	对象的析构顺序与构造顺序相反
	const关键字能够修饰对象，得到只读对象
	只读对象只能调用const成员函数
	所有对象共享类的成员函数
	隐藏的this指针用于表示当前对象

30，类的静态成员变量
	成员变量的回顾
		通过对象名能够访问public成员变量
		每个对象的成员变量都是专属的
		成员变量不能在对象之间共享

	在C++中可以定义静态成员变量
		静态成员变量属于整个类所有
		静态成员变量的生命期不依赖于任何对象
		可以通过类名直接访问公有静态成员变量
		所有对象共享类的静态成员变量
		可以通过对象名访问公有静态成员变量

	静态成员变量特性
		在定义时直接通过static关键字修饰
		静态成员变量需要在类外单独分配空间
		静态成员变量在程序内部位于全局数据区
	语法规则
		Type ClassName::Varname = value；

第25课小结
	类中可以通过static关键字定义静态成员变量
	静态成员变量隶属于类所有
	每个对象都可以访问静态成员变量
	静态成员变量在全局数据区分配空间
	静态成员变量的生命期为程序运行期

31，类的静态成员函数
	在C++中可以定义静态成员函数
		静态成员函数是类中特殊的成员函数
		静态成员函数属于整个类所有
		可以通过类名直接访问公有静态成员函数、
		可以通过对象名访问公有静态成员函数

								静态成员函数	vs    普通成员函数
		所有对象共享				Yes					Yes
		隐含this指针				No					Yes
		访问普通成员变量(函数)		No					Yes
		访问静态成员变量(函数)		Yes					Yes
		通过类名直接调用			Yes					No
		通过对象名直接调用			Yes					Yes

第26课小结
	静态成员函数是类中特殊的成员函数
	静态成员函数没有隐藏的this参数
	静态成员函数可以通过类名直接访问
	静态成员函数只能直接访问静态成员变量(函数)

32，二阶构造模式
	关于构造函数
		类的构造函数用于对象的初始化
		构造函数与类同名并且没有返回值
		构造函数在对象定义时自动被调用
	构造函数
		只提供自动初始化成员变量机会
		不能保证初始化逻辑一定成功
		执行return语句后构造函数立即结束
		构造函数能决定的只是对象的初始状态，而不是对象的诞生
	半成品对象的概念
		初始化操作不能按照预期完成而得到的对象
		半成品对象是合法的C++对象，也是bug的重要来源

	二阶构造
		在工程开发中的构造过程可分为
			资源无关的初始化操作
				不可能出现异常情况的操作
			需要使用系统资源的操作
				可能出现异常情况，如：内存申请，访问文件

								创建对象
									|
							资源无关初始操作	<---- 第一阶段构造
									|
							系统资源申请操作	<---- 第二阶段构造
									|
					False—————资源申请成功？—————True
					  |							  |
				删除半成品对象				   返回对象
					  |							  |
				  返回NULL						  |
				  	  |							  |
					  ————————————————————————————
					  				|
								   end

	二阶构造示例一
		class TwoPhaseCons
		{
		private:
			TwoPhaseCons(){		// 第一阶段构造函数
			}
			bool construct(){	// 第二阶段构造函数
				return true;
			}

		public:
			static TwoPhaseCons* NewInstance(); 	// 对象创建函数
		};

	二阶构造示例二
		TwoPhaseCons* TwoPhaseCons::NewInstance(){
			TwoPhaseCons* ret = new TwoPhaseCons();

			// 若第二阶段构造失败，返回NULL
			if( !(ret && ret->construct()) ){
				delete ret;
				ret = NULL;
			}

			return ret;
		}

第27课小结
	构造函数只能决定对象的初始化状态
	构造函数中初始化操作的失败不影响对象的诞生
	初始化不完全的半成品对象时bug的重要来源
	二阶构造人为的将初始化过程分为两部分
	二阶构造能够确保创建的对象都是完整初始化的


