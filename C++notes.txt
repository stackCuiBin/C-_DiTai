C到C++的升级

1，register关键字
	C++编译器有自己的优化方式
		C语言中无法获取register变量的地址
		C++中可以取得register变量的地址(优化方式是当去地址时，register关键字对变量的修饰失效)

2，在C语言中，重复定义多个同名的全局变量是合法的，多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。
	在C++中，不允许定义多个同名的全局变量

3, struct关键字的加强
	C语言中的struct定义了一组变量的集合，struct定义的标识符并不是一种新的类型；
	C++中的struct用于定义一个全新的类型

4，函数返回值及参数
   在C语言中
	int f()表示返回值为int，接受任意参数的函数
	f(void)表示返回值为int的无参函数
   在C++中
	int f()和int f(void)具有相同的意义
	表示返回值为int的无参函数
注：C++中所有的标识符都必须显示的声明类型，C语言中的默认类型在C++中是不合法的

第2课小结：
	C++更强调实用性，可以在任意的地方声明变量
	C++中的register只是一个兼容的作用
	C++编译器能够更好的进行优化
	C++中的任意标识符都必须显示的指明类型

5，const关键字
	C语言中的const：(1)修饰的变量是只读的，本质还是变量；(2)修饰的局部变量在栈上分配空间；
					(3)修饰的全局变量在只读存储区分配空间；(4)只在编译期有用，在运行期无用；
					(5)const修饰的变量不是真的常亮，它只是告诉编译器该变量不能出现在赋值符号的左边。
	C++中的const：C++在C的基础上对const进行了优化处理，当碰见const声明时在符号表中放入常量；
				  编译过程中若发现使用常量则以符号表中的值替换；
				  编译过程中若发现下述情况则给对应的常量分配存储空间，对const常量使用了extern，对const常量使用&操作符；
				  注意：C++编译器虽然可能为const常量分配空间，但不会使用其存储空间中的值。
	小结：C语言中的const变量是只读变量，会分配存储空间；
		  C++中的const变量可能分配存储空间：1)当const变量为全局，并且需要在其它文件中使用；2)当使用&操作符对const常量取地址。
  C++中const与宏定义
  	C++中的const常量类似于宏定义
		const int a = 5; 类似 #define a 5
	C++中的const常量早与宏定义不同
		const常量是由编译器处理
		编译器对const常量进行类型检查和作用域检查
		宏定义由预处理器处理，单纯的文本替换

第3课小结：
	与C语言不通，C++中的const不是只读变量
	C++中的const是一个真正意义上的常量
	C++编译器可能会为const常量分配空间(兼容C语言)
	C++完全兼容C语言中const常量的语法特性

6, bool类型
	C++中的bool类型
		C++在C语言的基本类型系统之上增加了bool
		C++中的bool可取的值只有true和false
		理论上bool只占用一个字节
		C++编译器会将非0值转换为true，0值转换为false

7，三目运算符
	C++对三目运算符进行了升级，可以作为左值，这句代码在C++中是正确的：(val_1 < val_2 ? val_1 : val_2) = 3;
	但是在C语言中是不可以作为左值的。

	C语言中的三目运算符返回的是变量值
		不能作为左值使用
	C++中的三目运算符可直接返回变量本身
		既可作为右值使用，又可作为左值使用
		注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用。
	C++对三目运算符做了什么？
		当三目运算符的可能返回都是变量时，返回的是变量的引用；
		当三目运算符的可能返回中有常量时，返回的是值。

8，C++中的引用
	变量名
		变量是一段实际连续存储空间的别名
		程序中通过变量来申请并命名存储空间
		通过变量名的名字可使用存储空间

	C++中新增了引用的概念
		引用可以看做一个已定义变量的别名
		引用的语法：Type& name = val;
		注意：普通引用在定义时必须用同类型的变量进行初始化

第4课小结：
	bool类型是C++新增加的基础类型
	bool类型的值只可能是true和false
	C++中的三目运算符可作为左值使用
	C++中的引用可以看做变量的别名来使用
	三目运算符的可能返回都是变量时，返回的是引用

9，const引用
	(1)在C++中可以声明const引用，const Type& name = val;
	const引用让变量拥有只读属性

	(2)当使用常量对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名
		const int&b = 1;	// OK
		int* p = (int *)&b;
		b = 5;				// error, 只读变量
		*p = 5;				// OK，修改变量的值
		结论：使用常量对const引用初始化后将生成一个只读变量！！！
		
  引用的本质
  	引用在C++中的内部实现是一个指针常量
		Type& name;		<--->		Type* const name;

		void f(int& a)				void f(int* const a)
		{				<--->		{
			a = 5;						*a = 5;
		}							}
	注意：C++编译器在编译过程中使用指针常量作为引用的内部实现，因此引用所占的空间大小与指针相同。
		  从使用的角度，引用只是一个别名，C++为了实用性而隐藏了引用的存储空间这一细节。

  引用的意义
  	C++中的引用旨在大多数的情况下代替指针
		功能性：可以满足多数需要使用指针的场合
		安全性：可以避开由于指针操作不当而带来的内存错误
		操作性：简单易用，又不失功能强大

第5课小结：
	引用作为变量别名而存在旨在代替指针
	const引用可以使得变量具有只读属性
	引用在编译器内部使用指针常量实现
	引用的最终本质为指针
	引用可以尽可能的避开内存错误(例如不要返回局部变量的引用)


