C到C++的升级

1，register关键字
	C++编译器有自己的优化方式
		C语言中无法获取register变量的地址
		C++中可以取得register变量的地址(优化方式是当去地址时，register关键字对变量的修饰失效)

2，在C语言中，重复定义多个同名的全局变量是合法的，多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。
	在C++中，不允许定义多个同名的全局变量

3, struct关键字的加强
	C语言中的struct定义了一组变量的集合，struct定义的标识符并不是一种新的类型；
	C++中的struct用于定义一个全新的类型

4，函数返回值及参数
   在C语言中
	int f()表示返回值为int，接受任意参数的函数
	f(void)表示返回值为int的无参函数
   在C++中
	int f()和int f(void)具有相同的意义
	表示返回值为int的无参函数
注：C++中所有的标识符都必须显示的声明类型，C语言中的默认类型在C++中是不合法的

第2课小结：
	C++更强调实用性，可以在任意的地方声明变量
	C++中的register只是一个兼容的作用
	C++编译器能够更好的进行优化
	C++中的任意标识符都必须显示的指明类型

5，const关键字
	C语言中的const：(1)修饰的变量是只读的，本质还是变量；(2)修饰的局部变量在栈上分配空间；
					(3)修饰的全局变量在只读存储区分配空间；(4)只在编译期有用，在运行期无用；
					(5)const修饰的变量不是真的常亮，它只是告诉编译器该变量不能出现在赋值符号的左边。
	C++中的const：C++在C的基础上对const进行了优化处理，当碰见const声明时在符号表中放入常量；
				  编译过程中若发现使用常量则以符号表中的值替换；
				  编译过程中若发现下述情况则给对应的常量分配存储空间，对const常量使用了extern，对const常量使用&操作符；
				  注意：C++编译器虽然可能为const常量分配空间，但不会使用其存储空间中的值。
	小结：C语言中的const变量是只读变量，会分配存储空间；
		  C++中的const变量可能分配存储空间：1)当const变量为全局，并且需要在其它文件中使用；2)当使用&操作符对const常量取地址。

	C++中const与宏定义
  	C++中的const常量类似于宏定义
		const int a = 5; 类似 #define a 5
	C++中的const常量早与宏定义不同
		const常量是由编译器处理
		编译器对const常量进行类型检查和作用域检查
		宏定义由预处理器处理，单纯的文本替换

第3课小结：
	与C语言不通，C++中的const不是只读变量
	C++中的const是一个真正意义上的常量
	C++编译器可能会为const常量分配空间(兼容C语言)
	C++完全兼容C语言中const常量的语法特性

6, bool类型
	C++中的bool类型
		C++在C语言的基本类型系统之上增加了bool
		C++中的bool可取的值只有true和false
		理论上bool只占用一个字节
		C++编译器会将非0值转换为true，0值转换为false

7，三目运算符
	C++对三目运算符进行了升级，可以作为左值，这句代码在C++中是正确的：(val_1 < val_2 ? val_1 : val_2) = 3;
	但是在C语言中是不可以作为左值的。

	C语言中的三目运算符返回的是变量值
		不能作为左值使用
	C++中的三目运算符可直接返回变量本身
		既可作为右值使用，又可作为左值使用
		注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用。
	C++对三目运算符做了什么？
		当三目运算符的可能返回都是变量时，返回的是变量的引用；
		当三目运算符的可能返回中有常量时，返回的是值。

8，C++中的引用
	变量名
		变量是一段实际连续存储空间的别名
		程序中通过变量来申请并命名存储空间
		通过变量名的名字可使用存储空间

	C++中新增了引用的概念
		引用可以看做一个已定义变量的别名
		引用的语法：Type& name = val;
		注意：普通引用在定义时必须用同类型的变量进行初始化

第4课小结：
	bool类型是C++新增加的基础类型
	bool类型的值只可能是true和false
	C++中的三目运算符可作为左值使用
	C++中的引用可以看做变量的别名来使用
	三目运算符的可能返回都是变量时，返回的是引用

9，const引用
	(1)在C++中可以声明const引用，const Type& name = val;
	const引用让变量拥有只读属性

	(2)当使用常量对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名
		const int&b = 1;	// OK
		int* p = (int *)&b;
		b = 5;				// error, 只读变量
		*p = 5;				// OK，修改变量的值
		结论：使用常量对const引用初始化后将生成一个只读变量！！！
		
  引用的本质
  	引用在C++中的内部实现是一个指针常量
		Type& name;		<--->		Type* const name;

		void f(int& a)				void f(int* const a)
		{				<--->		{
			a = 5;						*a = 5;
		}							}
	注意：C++编译器在编译过程中使用指针常量作为引用的内部实现，因此引用所占的空间大小与指针相同。
		  从使用的角度，引用只是一个别名，C++为了实用性而隐藏了引用的存储空间这一细节。

  引用的意义
  	C++中的引用旨在大多数的情况下代替指针
		功能性：可以满足多数需要使用指针的场合
		安全性：可以避开由于指针操作不当而带来的内存错误
		操作性：简单易用，又不失功能强大

第5课小结：
	引用作为变量别名而存在旨在代替指针
	const引用可以使得变量具有只读属性
	引用在编译器内部使用指针常量实现
	引用的最终本质为指针
	引用可以尽可能的避开内存错误(例如不要返回局部变量的引用)

10，内联函数
	C++中推荐使用内联函数代替宏代码片段
	C++中使用inline关键字声明内联函数
	内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求

	C++编译器可以将一个函数进行内联编译
	被C++编译器内联编译的函数叫做内联函数
	C++编译器直接将函数体插入到函数调用的地方
	内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)

	内联函数具有普通函数的特征(参数检查，返回类型等)
	函数的内敛请求可能被编译器拒绝
	函数被内联后，函数体直接扩展到调用的地方
	(宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程，因此可能出现副作用)

	现代C++编译器能够进行编译优化，一些函数即使没有inline声明，也可能被内联编译
	一些现代C++编译器提供了扩展语法，能够对函数进行强制内联，如：
		g++：  __attribute__((always_inline))属性
		MSVC： __forceinline

	注意事项：
	C++中inline内联编译的限制
		不能存在任何形式的循环语句
		不能存在过多的条件判断语句
		函数体不能过于庞大
		不能对函数进行取址操作
		函数内联声明必须在调用语句之前

第6课小结：
	C++中可以通过inline声明内联函数
	编译器直接将内联函数体扩展到函数调用的地方
	inline只是一种请求，编译器不一定允许这种请求
	内联函数省去了函数调用时压栈，跳转和返回的开销

11，函数参数的默认值
	C++中可以在函数声明时为参数提供一个默认值
	当函数调用时没有提供参数的值，则使用默认值
	参数的默认值必须在函数声明中指定

	函数默认参数的规则
		参数的默认值必须从右向左提供
		函数调用时使用了默认值，则后续参数必须使用默认值

	在C++中可以为函数提供占位参数
		占位参数只有参数类型声明，而没有参数名声明
		一般情况下，在函数体内部无法使用占位参数
	函数占位参数的意义
		占位参数与默认参数结合起来使用
		兼容C语言程序中可能出现的不规范写法

第7课小结：
	C++中支持函数参数的默认值
	如果函数调用时没有提供参数值，则使用默认值
	参数的默认值必须从右向左提供
	参数调用时使用了默认值，则后续参数必须使用默认值
	C++中支持占位参数，用于兼容C语言中的不规范写法

12，C++中的函数重载
	函数重载
		用同一个函数名定义不同的函数
		当函数名和不同的参数搭配时函数的含义不用

	函数重载至少满足下面的一个条件
		参数个数不同
		参数类型不同
		参数顺序不同

	编译器调用重载函数的准则
		将所有同名函数作为候选者
		尝试寻找可行的候选函数
			精确匹配参数
			通过默认参数能够匹配实参
			通过默认类型转换匹配实参
		匹配失败
			最终寻找到的候选函数不唯一，出现二义性，编译失败
			无法匹配所有候选者，函数未定义，编译失败。

	函数重载的注意事项
		重载函数早本质上是相互独立的不同函数
		重载函数的函数类型不同
		函数返回值不能作为函数重载的依据
		函数重载是由函数名和参数列表决定的

第8课小结：
	函数重载是C++中引入的概念
	函数重载用于模拟自然语言中的词汇搭配
	函数重载使得C++具有更丰富的语义表达能力
	函数重载的本质为相互独立的不同函数
	C++中通过函数名和函数参数确定函数调用

13，重载和指针
	函数重载遇上函数指针
		将重载函数名赋值给函数指针时
			根据重载规则挑选与函数指针参数列表一致的候选者
			严格匹配候选者的函数类型与函数指针的函数类型
	注意：函数重载必然发生在同一个作用域中
		  编译器需要用参数列表或函数类型进行函数选择
		  无法直接通过函数名得到重载函数的入口地址

	C++和C的相互调用
		实际工程中C++和C代码相互调用是不可避免的
		C++编译器能够兼容C语言的编译方式
		C++编译器会优先使用C++编译的方式
		extern 关键字能强制让C++编译器进行C方式的编译
			extern "C"
			{
			}

	如何保证一段C代码只会以C的方式被编译？
	解决方案：
		__cplusplus是C++编译器内置的标准宏定义
		__cplusplus的意义
			确保C代码以统一的C方式被编译成目标文件

	注意事项：
		C++编译器不能以C的方式编译重载函数
		编译方式决定函数名被编译后的目标名
			C++编译方式将函数名和参数列表编译成目标名
			C编译方式只将函数名作为目标名进行编译

第9课小结：
	函数重载是C++对C的一个重要升级
	函数重载通过函数参数列表区分不同的同名函数
	extern关键字能够实现C和C++的相互调用(extern中决不可存在重载函数)
	编译方式决定符号表中的函数名的最终目标名

14，动态内存分配
	C++中的动态内存分配
		C++中通过 new 关键字进行动态内存申请
		C++中的动态内存申请是基于类型进行的
		delete 关键字用于内存释放
		变量申请：
		Type× pointer = new Type;
		// ...
		delete pointer;
		数组申请：
		Type* pointer = new Type[N];
		// ...
		delete[] pointer;

	new 关键字与malloc函数的区别
		new 关键字是C++的一部分
		malloc是由C库提供的函数
		new以具体类型为单位进行内存分配
		malloc以字节为单位进行内存分配
		new在申请单个类型变量时可进行初始化
		malloc不具备内存初始化的特性

	new关键字的初始化
		int* pi = new int(1);
		float* pf = new float(2.0f);
		char* pc = new char('c');

15，C++中的命名空间
	在C语言中只有一个全局作用域
		C语言中所有的全局标识符共享同一个作用域
		标识符之间可能发生冲突
	C++中提出了命名空间的概念
		命名空间将全局作用域分成不同的部分
		不同命名空间中的标识符可以同名而不发生冲突
		命名空间可以相互嵌套
		全局作用域也叫默认命名空间
	C++命名空间的定义
		namespace Name
		{
			namespace Internal	// 嵌套
			{
				/* ... */
			}

			/* ... */
		}
	C++命名空间的使用
		使用整个命名空间：using namespace name;
		使用命名空间中的变量：using name::variable
		使用默认命名空间中的变量：::variable

第10课小结：
	C++中内置了动态内存分配的专用关键字
	C++中的动态内存分配可以同时进行初始化
	C++中的动态内存分配是基于类型进行的
	C++中的命名空间概念用于解决名称冲突问题

16，强制类型转换
	C方式强制类型转换存在问题
		过于粗暴
			任意类型之间都可以进行转换，编译器很难判断其正确性
		难于定位
			在源码中无法快速定位所有使用强制类型转换的语句

	C++将强制类型转换分为4种不同的类型	用法：xxx_cast< Type >( Expression )
		static_cast
			用于基本类型间的转换
			不能用于基本类型指针间的转换
			用于有继承关系类对象之间的转换和类指针之间的转换
		const_cast
			用于去除变量的只读属性
			强制转换的目标类型必须是指针或引用
		dynamic_cast
			用于有继承关系的类指针间的转换
			用于有交叉关系的类指针间的转换
			具有类型检查的功能
			需要虚函数的支持
		reinterpret_cast
			用于指针类型间的强制转换
			用于整数和指针类型间的强制转换

第11课小结：
	C方式的强制类型转换
		过于粗暴
		潜在的问题不易被发现
		不易在代码中定位
	新式类型转换以C++关键字的方式出现
		编译器能够帮助检查潜在的问题
		非常方便的在代码中定位
		支持动态类型识别( dynamic_cast )


