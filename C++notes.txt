C到C++的升级

1，register关键字
	C++编译器有自己的优化方式
		C语言中无法获取register变量的地址
		C++中可以取得register变量的地址(优化方式是当去地址时，register关键字对变量的修饰失效)

2，在C语言中，重复定义多个同名的全局变量是合法的，多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。
	在C++中，不允许定义多个同名的全局变量

3, struct关键字的加强
	C语言中的struct定义了一组变量的集合，struct定义的标识符并不是一种新的类型；
	C++中的struct用于定义一个全新的类型

4，函数返回值及参数
   在C语言中
	int f()表示返回值为int，接受任意参数的函数
	f(void)表示返回值为int的无参函数
   在C++中
	int f()和int f(void)具有相同的意义
	表示返回值为int的无参函数
注：C++中所有的标识符都必须显示的声明类型，C语言中的默认类型在C++中是不合法的

第2课小结：
	C++更强调实用性，可以在任意的地方声明变量
	C++中的register只是一个兼容的作用
	C++编译器能够更好的进行优化
	C++中的任意标识符都必须显示的指明类型

5，const关键字
	C语言中的const：(1)修饰的变量是只读的，本质还是变量；(2)修饰的局部变量在栈上分配空间；
					(3)修饰的全局变量在只读存储区分配空间；(4)只在编译期有用，在运行期无用；
					(5)const修饰的变量不是真的常亮，它只是告诉编译器该变量不能出现在赋值符号的左边。
	C++中的const：C++在C的基础上对const进行了优化处理，当碰见const声明时在符号表中放入常量；
				  编译过程中若发现使用常量则以符号表中的值替换；
				  编译过程中若发现下述情况则给对应的常量分配存储空间，对const常量使用了extern，对const常量使用&操作符；
				  注意：C++编译器虽然可能为const常量分配空间，但不会使用其存储空间中的值。
	小结：C语言中的const变量是只读变量，会分配存储空间；
		  C++中的const变量可能分配存储空间：1)当const变量为全局，并且需要在其它文件中使用；2)当使用&操作符对const常量取地址。
  C++中const与宏定义
  	C++中的const常量类似于宏定义
		const int a = 5; 类似 #define a 5
	C++中的const常量早与宏定义不同
		const常量是由编译器处理
		编译器对const常量进行类型检查和作用域检查
		宏定义由预处理器处理，单纯的文本替换

第3课小结：
	与C语言不通，C++中的const不是只读变量
	C++中的const是一个真正意义上的常量
	C++编译器可能会为const常量分配空间(兼容C语言)
	C++完全兼容C语言中const常量的语法特性


