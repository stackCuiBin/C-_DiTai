C到C++的升级

1，register关键字
	C++编译器有自己的优化方式
		C语言中无法获取register变量的地址
		C++中可以取得register变量的地址(优化方式是当去地址时，register关键字对变量的修饰失效)

2，在C语言中，重复定义多个同名的全局变量是合法的，多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。
	在C++中，不允许定义多个同名的全局变量

3, struct关键字的加强
	C语言中的struct定义了一组变量的集合，struct定义的标识符并不是一种新的类型；
	C++中的struct用于定义一个全新的类型

4，函数返回值及参数
   在C语言中
	int f()表示返回值为int，接受任意参数的函数
	f(void)表示返回值为int的无参函数
   在C++中
	int f()和int f(void)具有相同的意义
	表示返回值为int的无参函数
注：C++中所有的标识符都必须显示的声明类型，C语言中的默认类型在C++中是不合法的

第2课小结：
	C++更强调实用性，可以在任意的地方声明变量
	C++中的register只是一个兼容的作用
	C++编译器能够更好的进行优化
	C++中的任意标识符都必须显示的指明类型

5，const关键字
	C语言中的const：(1)修饰的变量是只读的，本质还是变量；(2)修饰的局部变量在栈上分配空间；
					(3)修饰的全局变量在只读存储区分配空间；(4)只在编译期有用，在运行期无用；
					(5)const修饰的变量不是真的常亮，它只是告诉编译器该变量不能出现在赋值符号的左边。
	C++中的const：C++在C的基础上对const进行了优化处理，当碰见const声明时在符号表中放入常量；
				  编译过程中若发现使用常量则以符号表中的值替换；
				  编译过程中若发现下述情况则给对应的常量分配存储空间，对const常量使用了extern，对const常量使用&操作符；
				  注意：C++编译器虽然可能为const常量分配空间，但不会使用其存储空间中的值。
	小结：C语言中的const变量是只读变量，会分配存储空间；
		  C++中的const变量可能分配存储空间：1)当const变量为全局，并且需要在其它文件中使用；2)当使用&操作符对const常量取地址。

	C++中const与宏定义
  	C++中的const常量类似于宏定义
		const int a = 5; 类似 #define a 5
	C++中的const常量早与宏定义不同
		const常量是由编译器处理
		编译器对const常量进行类型检查和作用域检查
		宏定义由预处理器处理，单纯的文本替换

第3课小结：
	与C语言不通，C++中的const不是只读变量
	C++中的const是一个真正意义上的常量
	C++编译器可能会为const常量分配空间(兼容C语言)
	C++完全兼容C语言中const常量的语法特性

6, bool类型
	C++中的bool类型
		C++在C语言的基本类型系统之上增加了bool
		C++中的bool可取的值只有true和false
		理论上bool只占用一个字节
		C++编译器会将非0值转换为true，0值转换为false

7，三目运算符
	C++对三目运算符进行了升级，可以作为左值，这句代码在C++中是正确的：(val_1 < val_2 ? val_1 : val_2) = 3;
	但是在C语言中是不可以作为左值的。

	C语言中的三目运算符返回的是变量值
		不能作为左值使用
	C++中的三目运算符可直接返回变量本身
		既可作为右值使用，又可作为左值使用
		注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用。
	C++对三目运算符做了什么？
		当三目运算符的可能返回都是变量时，返回的是变量的引用；
		当三目运算符的可能返回中有常量时，返回的是值。

8，C++中的引用
	变量名
		变量是一段实际连续存储空间的别名
		程序中通过变量来申请并命名存储空间
		通过变量名的名字可使用存储空间

	C++中新增了引用的概念
		引用可以看做一个已定义变量的别名
		引用的语法：Type& name = val;
		注意：普通引用在定义时必须用同类型的变量进行初始化

第4课小结：
	bool类型是C++新增加的基础类型
	bool类型的值只可能是true和false
	C++中的三目运算符可作为左值使用
	C++中的引用可以看做变量的别名来使用
	三目运算符的可能返回都是变量时，返回的是引用

9，const引用
	(1)在C++中可以声明const引用，const Type& name = val;
	const引用让变量拥有只读属性

	(2)当使用常量对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名
		const int&b = 1;	// OK
		int* p = (int *)&b;
		b = 5;				// error, 只读变量
		*p = 5;				// OK，修改变量的值
		结论：使用常量对const引用初始化后将生成一个只读变量！！！
		
  引用的本质
  	引用在C++中的内部实现是一个指针常量
		Type& name;		<--->		Type* const name;

		void f(int& a)				void f(int* const a)
		{				<--->		{
			a = 5;						*a = 5;
		}							}
	注意：C++编译器在编译过程中使用指针常量作为引用的内部实现，因此引用所占的空间大小与指针相同。
		  从使用的角度，引用只是一个别名，C++为了实用性而隐藏了引用的存储空间这一细节。

  引用的意义
  	C++中的引用旨在大多数的情况下代替指针
		功能性：可以满足多数需要使用指针的场合
		安全性：可以避开由于指针操作不当而带来的内存错误
		操作性：简单易用，又不失功能强大

第5课小结：
	引用作为变量别名而存在旨在代替指针
	const引用可以使得变量具有只读属性
	引用在编译器内部使用指针常量实现
	引用的最终本质为指针
	引用可以尽可能的避开内存错误(例如不要返回局部变量的引用)

10，内联函数
	C++中推荐使用内联函数代替宏代码片段
	C++中使用inline关键字声明内联函数
	内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求

	C++编译器可以将一个函数进行内联编译
	被C++编译器内联编译的函数叫做内联函数
	C++编译器直接将函数体插入到函数调用的地方
	内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)

	内联函数具有普通函数的特征(参数检查，返回类型等)
	函数的内敛请求可能被编译器拒绝
	函数被内联后，函数体直接扩展到调用的地方
	(宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程，因此可能出现副作用)

	现代C++编译器能够进行编译优化，一些函数即使没有inline声明，也可能被内联编译
	一些现代C++编译器提供了扩展语法，能够对函数进行强制内联，如：
		g++：  __attribute__((always_inline))属性
		MSVC： __forceinline

	注意事项：
	C++中inline内联编译的限制
		不能存在任何形式的循环语句
		不能存在过多的条件判断语句
		函数体不能过于庞大
		不能对函数进行取址操作
		函数内联声明必须在调用语句之前

第6课小结：
	C++中可以通过inline声明内联函数
	编译器直接将内联函数体扩展到函数调用的地方
	inline只是一种请求，编译器不一定允许这种请求
	内联函数省去了函数调用时压栈，跳转和返回的开销

11，函数参数的默认值
	C++中可以在函数声明时为参数提供一个默认值
	当函数调用时没有提供参数的值，则使用默认值
	参数的默认值必须在函数声明中指定

	函数默认参数的规则
		参数的默认值必须从右向左提供
		函数调用时使用了默认值，则后续参数必须使用默认值

	在C++中可以为函数提供占位参数
		占位参数只有参数类型声明，而没有参数名声明
		一般情况下，在函数体内部无法使用占位参数
	函数占位参数的意义
		占位参数与默认参数结合起来使用
		兼容C语言程序中可能出现的不规范写法

第7课小结：
	C++中支持函数参数的默认值
	如果函数调用时没有提供参数值，则使用默认值
	参数的默认值必须从右向左提供
	参数调用时使用了默认值，则后续参数必须使用默认值
	C++中支持占位参数，用于兼容C语言中的不规范写法

12，C++中的函数重载
	函数重载
		用同一个函数名定义不同的函数
		当函数名和不同的参数搭配时函数的含义不用

	函数重载至少满足下面的一个条件
		参数个数不同
		参数类型不同
		参数顺序不同

	编译器调用重载函数的准则
		将所有同名函数作为候选者
		尝试寻找可行的候选函数
			精确匹配参数
			通过默认参数能够匹配实参
			通过默认类型转换匹配实参
		匹配失败
			最终寻找到的候选函数不唯一，出现二义性，编译失败
			无法匹配所有候选者，函数未定义，编译失败。

	函数重载的注意事项
		重载函数早本质上是相互独立的不同函数
		重载函数的函数类型不同
		函数返回值不能作为函数重载的依据
		函数重载是由函数名和参数列表决定的

第8课小结：
	函数重载是C++中引入的概念
	函数重载用于模拟自然语言中的词汇搭配
	函数重载使得C++具有更丰富的语义表达能力
	函数重载的本质为相互独立的不同函数
	C++中通过函数名和函数参数确定函数调用

13，重载和指针
	函数重载遇上函数指针
		将重载函数名赋值给函数指针时
			根据重载规则挑选与函数指针参数列表一致的候选者
			严格匹配候选者的函数类型与函数指针的函数类型
	注意：函数重载必然发生在同一个作用域中
		  编译器需要用参数列表或函数类型进行函数选择
		  无法直接通过函数名得到重载函数的入口地址

	C++和C的相互调用
		实际工程中C++和C代码相互调用是不可避免的
		C++编译器能够兼容C语言的编译方式
		C++编译器会优先使用C++编译的方式
		extern 关键字能强制让C++编译器进行C方式的编译
			extern "C"
			{
			}

	如何保证一段C代码只会以C的方式被编译？
	解决方案：
		__cplusplus是C++编译器内置的标准宏定义
		__cplusplus的意义
			确保C代码以统一的C方式被编译成目标文件

	注意事项：
		C++编译器不能以C的方式编译重载函数
		编译方式决定函数名被编译后的目标名
			C++编译方式将函数名和参数列表编译成目标名
			C编译方式只将函数名作为目标名进行编译

第9课小结：
	函数重载是C++对C的一个重要升级
	函数重载通过函数参数列表区分不同的同名函数
	extern关键字能够实现C和C++的相互调用(extern中决不可存在重载函数)
	编译方式决定符号表中的函数名的最终目标名

14，动态内存分配
	C++中的动态内存分配
		C++中通过 new 关键字进行动态内存申请
		C++中的动态内存申请是基于类型进行的
		delete 关键字用于内存释放
		变量申请：
		Type× pointer = new Type;
		// ...
		delete pointer;
		数组申请：
		Type* pointer = new Type[N];
		// ...
		delete[] pointer;

	new 关键字与malloc函数的区别
		new 关键字是C++的一部分
		malloc是由C库提供的函数
		new以具体类型为单位进行内存分配
		malloc以字节为单位进行内存分配
		new在申请单个类型变量时可进行初始化
		malloc不具备内存初始化的特性

	new关键字的初始化
		int* pi = new int(1);
		float* pf = new float(2.0f);
		char* pc = new char('c');

15，C++中的命名空间
	在C语言中只有一个全局作用域
		C语言中所有的全局标识符共享同一个作用域
		标识符之间可能发生冲突
	C++中提出了命名空间的概念
		命名空间将全局作用域分成不同的部分
		不同命名空间中的标识符可以同名而不发生冲突
		命名空间可以相互嵌套
		全局作用域也叫默认命名空间
	C++命名空间的定义
		namespace Name
		{
			namespace Internal	// 嵌套
			{
				/* ... */
			}

			/* ... */
		}
	C++命名空间的使用
		使用整个命名空间：using namespace name;
		使用命名空间中的变量：using name::variable
		使用默认命名空间中的变量：::variable

第10课小结：
	C++中内置了动态内存分配的专用关键字
	C++中的动态内存分配可以同时进行初始化
	C++中的动态内存分配是基于类型进行的
	C++中的命名空间概念用于解决名称冲突问题

16，强制类型转换
	C方式强制类型转换存在问题
		过于粗暴
			任意类型之间都可以进行转换，编译器很难判断其正确性
		难于定位
			在源码中无法快速定位所有使用强制类型转换的语句

	C++将强制类型转换分为4种不同的类型	用法：xxx_cast< Type >( Expression )
		static_cast
			用于基本类型间的转换
			不能用于基本类型指针间的转换
			用于有继承关系类对象之间的转换和类指针之间的转换
		const_cast
			用于去除变量的只读属性
			强制转换的目标类型必须是指针或引用
		dynamic_cast
			用于有继承关系的类指针间的转换
			用于有交叉关系的类指针间的转换
			具有类型检查的功能
			需要虚函数的支持
		reinterpret_cast
			用于指针类型间的强制转换
			用于整数和指针类型间的强制转换

第11课小结：
	C方式的强制类型转换
		过于粗暴
		潜在的问题不易被发现
		不易在代码中定位
	新式类型转换以C++关键字的方式出现
		编译器能够帮助检查潜在的问题
		非常方便的在代码中定位
		支持动态类型识别( dynamic_cast )

17，经典问题剖析
	const常量的判别准则
		只有用字面量初始化的const常量才会进入符号表
		使用其它变量初始化的const常量仍然是只读变量
		被volatile修饰的const常量不会进入符号表
		在编译期间不能直接确定初始值的const标识符，都被作为只读变量处理
	const引用的类型与初始化变量的类型
		相同：初始化变量成为只读变量
		不同：生成一个新的只读变量

	指针是一个变量
		值为一个内存地址，不需要初始化，可以保存不同的地址
		通过指针可以访问对应内存地址中的值
		指针可以被const修饰为常量或者只读变量
	引用只是一个变量的新名字
		对引用的操作(赋值，取地址等)都会传递到代表的变量上
		const引用使其代表的变量具有只读属性
		引用必须在定义时初始化，之后无法代表其它变量
	从使用C++语言的角度来看
		引用与指针没有任何的关系
		引用是变量的新名字，操作引用就是操作对应的变量
	从C++编译器的角度来看
		为了支持新概念“引用”必须要有一个有效的解决方案
		在编译器内部，使用指针常量来实现“引用”
		因此“引用”在定义时必须初始化

第12课小结：
	指针是一个变量
	引用是一个变量的新名字
	const引用能够生成新的只读变量
	在编译器内部使用指针常量实现“引用”
	编译时不能直接确定初始值的const标识符都是只读变量
	C++不支持定义引用数组

18-1，面向对象的基本概念
	面向对象的意义
		将日常生活中习惯的思维方式引入程序设计中
		将需求中的概念直观的映射到解决方案中
		以模块为中心构建可复用的软件系统
		提高软件产品的可维护性和可扩展性

	类和对象是面向对象中的两个基本概念
		类：指的是一类事物，是一个抽象的概念
		对象：指的是属于某个类的具体实体
		类是一种模型，这种模型可以创建出不同的对象实体
		对象实体是类模型的一个具体实例
		一个类可以有很多对象，而一个对象必然属于某个类

第13课小结
	面向对象是当今软件开发中的重要方法
	类和对象是面向对象理论中的基本概念
	类和对象均来源于日常生活中
	每个类可以有多个对象
	每个对象必然属于某个类

18-2，面向对象基本概念
	类之间的基本关系
		继承
			从已存在类细分出来的类和原类之间具有继承关系( is-a )
			继承的类(子类)拥有原类(父类)的所有属性和行为
		组合
			一些类的存在必须依赖于其它的类，这种关系叫组合
			组合的类在某一局部上由其它的类组成

第14课小结
	类之间可以存在继承关系或组合关系
	继承关系中子类拥有父类的一切属性和行为
	组合关系是类之间整体和部分的关系
	类及类之间的关系可以有不同的表示法
	编译器对类的表示法有具体的要求

19，类的封装
	类通常分为以下两个部分
		类的实现细节
		类的使用方式
		当使用类时，不需要关心其实现细节
		当创建类时，才需要考虑其内部实现细节

	封装的基本概念
		根据经验：并不是类的每个属性都是对外公开的
				  而一些类的属性时对外公开的
				  必须在类的表示法中定义属性的行为的公开级别
				  	类似文件系统中的文件权限
	C++中类的封装
		成员变量：C++中用于表示类属性的变量
		成员函数：C++中用于表示类行为的函数
		C++中可以给成员变量和成员函数定义访问级别
			public
				成员变量和成员函数可以在类的内部和外界访问和调用
			private
				成员变量和成员函数只能在类的内部被访问和调用

	类成员的作用域
		类成员的作用域都只在类的内部，外部无法直接访问
		成员函数可以直接访问成员变量和调用成员函数
		类的外部可以通过类变量访问public成员
		类成员的作用域与访问级别没有关系
			C++中用struct定义的类中所有成员默认为public

第15课小结
	类通常可以分为使用方式和内部细节两部分
	类的封装机制使得使用方式和内部细节相分离
	C++中通过定义类成员的访问级别实现封装机制
	public成员可以在类的内部和外界访问和调用
	private成员只能在类的内部被访问和调用

20，类的真正形态
	类的关键字
		struct在C语言中已经有了自己的含义，必须继续兼容
		早C++中提供了新的关键字class用于类定义
		class和struct的用法是完全相同的
			不同点是什么？
			在用struct定义类时，所有成员的默认访问级别为public
			在用class定义类时，所有成员的默认访问级别为private

	C++中的类支持声明和实现的分离
	将类的实现和定义分开
		.h头文件中只有类的声明
			成员变量和成员函数的声明
		.cpp源文件中完成类的其它实现
			成员函数的具体实现

第16课小结
	C++引进了新的关键字class用于定义类
	struct和class的区别在于默认访问级别的不同
	C++中的类支持声明和实现的分离
		在头文件中声明类
		在原文件中实现类

21，对象的构造(上)
	从程序设计的角度，对象只是变量，因此：
		在栈上创建对象时，成员变量初始值为随机值
		在堆上创建对象时，成员变量初始值为随机值
		在静态存储区创建对象时，成员变量初始为0值

	构造函数
		C++中可以定义与类名相同的特殊成员函数
			这种特殊的成员函数叫做构造函数
				构造没有任何返回类型的声明
				构造函数在对象定义时自动被调用

第17课小结
	每个对象在使用之前都应该初始化
	类的构造函数用于对象的初始化
	构造函数与类同名并且没有返回值
	构造函数在对象定义时被自动被调用

22，对象的构造(中)
	构造函数
		带参数的构造函数
			构造函数可以根据需要定义参数
			一个类中可以存在多个重载的构造函数
			构造函数的重载遵循C++重载的规则
				class Test
				{
				public:
					Test() {}
					Test(int v) {}
				};

				int main()
				{
					Test t;			// Test()
					Test t1(1);		// Test(int v)
					Test t2 = 1;	// Test(int v)

					return 0;
				}

	友情提醒
		对象定义和对象声明不同
			对象定义：申请对象的空间并调用构造函数
			对象声明：告诉编器存在这样一个对象

	构造函数的调用
		一般情况下，构造韩顺在对象定义时被自动调用
		一些特殊情况下，需要手工调用构造函数

第18课小结
	构造函数可以根据需要定义参数
	构造函数之间可以存在重载关系
	构造函数遵循C++中重载函数的规则
	对象定义时会出发构造函数的调用
	在一些情况下可以手动调用构造函数

23，对象的构造(下)
	特殊的构造函数
		两个特殊的构造函数
			无参构造函数
				没有参数的构造函数
				当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空
			拷贝构造函数
				参数为const class_name& 的构造函数
				当类中没有定义拷贝构造函数时，编译器默认提供一个拷贝构造函数，简单的进行成员变量的值复制

	拷贝构造函数的意义
		兼容C语言的初始化方式
		初始化行为能够符合预期的逻辑
		浅拷贝
			拷贝后对象的物理状态相同
		深拷贝
			拷贝后对象的逻辑状态相同
		(编译器提供的拷贝构造函数只进行浅拷贝)

		什么时候需要进行深拷贝？
			对象中有成员指代了系统中的资源
				成员指向了动态内存空间
				成员开打了外存中的文件
				成员使用了系统中的网络端口
		
		一般性原则
			自定义拷贝构造函数，必然需要实现深拷贝

第19课小结
	C++编译器会默认提供构造函数
	无参构造函数用于定义对象的默认初始状态
	拷贝构造函数在创建对象时拷贝对象的状态
	对象的拷贝有浅拷贝和深拷贝两种方式
		浅拷贝使得对象的物理状态相同
		深拷贝使得对象的逻辑状态相同


24，初始化列表的使用
	类成员的初始化
		C++中提供了初始化列表对成员变量进行初始化
			语法规则
				Classname::ClassName() :
							m1(v1),m2(v1,v2),m3(v3)
				{
					// some other initialize operation
				}
	注意事项
		成员的初始化顺序与成员的声明顺序相同
		成员的初始化顺序与初始化列表中的位置无关
		初始化列表先于构造函数的函数体执行

	类中的const成员会被分配空间的(和类空间一致)
	类中的const成员的本质是只读变量
	类中的const成员只能在初始化列中指定初始值
	(编译器无法直接得到const成员的初始值，因此无法进入符号表成为真正意义上的常亮)

	初始化与赋值不同
		初始化：对正在创建的对象进行初值设置
		赋值：对已经存在的对象进行值设置

第20课小结
	类中可以使用初始化列表对成员进行初始化
	初始化列表先于构造函数体执行
	类中可以定义const成员变量
	const成员变量必须在初始化列表中指定初值
	const成员变量为只读变量


26，对象的构造顺序
	对于局部对象
		当程序执行流到达对象的定义语句时进行构造
			对象定义-> 构造
	对于堆对象
		当程序执行流到达new语句时创建对象
		使用new创建对象将自动触发构造函数的调用
	对于全局对象
		对象的构造顺序时不确定的
		不同的编译器使用不同的规则确定构造顺序

第21课小结
	局部对象的构造顺序依赖于程序的执行流
	堆对象的构造顺序依赖于new的使用顺序
	全局对象的构造顺序时不确定的

27，对象的销毁
	一般而言，需要销毁的对象都应该做清理
	解决方案：
		为每个类都提供一个public的free函数
		对象不在需要时立即调用free函数进行清理
	存在的问题
		free只是一个普通的函数，必须显示的调用
		对象销毁前没有做清理，很可能造成资源泄露

	C++的类中可以定义一个特殊的清理函数
		这个特殊的清理函数叫做析构函数
		析构函数的功能与构造函数相反
	定义：～ClassName()
		析构函数没有参数也没有返回值类型声明
		析构函数在对象销毁时自动被调用

	析构函数的定义准则
		当类中自定义了构造函数，并且构造函数中使用了系统资源(如：内存申请，文件打开等)，
		则需要自定义析构函数

第22课小结
	析构函数时对象销毁时进行清理的特殊函数
	析构函数在对象销毁时自动被调用
	析构函数时对象释放系统资源的保障

28，临时对象 
	构造函数是一个特殊的函数
		是否可以直接调用？
		是否可以在构造函数中调用构造函数？
		直接调用构造函数的行为是什么？
		答案：
			直接调用构造函数将会产生一个临时对象
			临时对象的生命周期只有一条语句的时间
			临时堆笑的作用域只在一条语句中
			临时对象的C++中值得警惕的灰色地带

第23课小结
	直接调用构造函数将产生一个临时对象
	临时对象是性能的瓶颈，也是bug的来源之一
	现在C++编译器会尽力避开临时对象
	实际工程开发中需要人为的避开临时对象

29，经典问题解析
	关于析构的疑问
		单个对象创建时构造函数的调用顺序
			1，调用父类的构造过程
			2，调用成员变量的构造函数(调用顺序与声明顺序相同)
			3，调用类自身的构造函数
				析构函数与对应构造函数的调用顺序相反

		多个对象析构时
			析构顺序与构造顺序相反

		对于栈对象和全局对象，类似于入栈与出栈的顺序，最后构造的对象最先析构

		堆对象的析构发生在使用delete的时候，与delete的使用顺序相关

	const关键字能否修饰类的对象？如果可以，有什么特性？
		const关键字能够修饰对象
		const修饰的对象为只读对象
		只读对象的成员变量不允许被改变
		只读对象是编译阶段的概念，运行时无效 
	C++中的const成员函数
		const对象只能调用const的成员函数
		const成员函数中只能调用const成员函数
		const成员函数中不能直接修改成员变量的值
	const成员函数的定义
		Type ClassName::function(Type p) const
		类中的函数声明与实际函数定义中都必须带const关键字

	成员函数和成员变量都是隶属于具体对象的吗？
		从面向对象的角度
			对象由属性(成员变量)和方法(成员函数)构成
		从程序运行的角度
			对象由数据和函数构成
				数据可以位于栈、堆和全局数据区
				函数只能位于代码段
	结论
		每一个对象拥有自己独立的属性(成员变量)
		所有的对象共享类的方法(成员函数)
		方法能够直接访问对象的属性
		方法中的隐藏参数 this 用于指代当前对象

第24课小结
	对象的析构顺序与构造顺序相反
	const关键字能够修饰对象，得到只读对象
	只读对象只能调用const成员函数
	所有对象共享类的成员函数
	隐藏的this指针用于表示当前对象

30，类的静态成员变量
	成员变量的回顾
		通过对象名能够访问public成员变量
		每个对象的成员变量都是专属的
		成员变量不能在对象之间共享

	在C++中可以定义静态成员变量
		静态成员变量属于整个类所有
		静态成员变量的生命期不依赖于任何对象
		可以通过类名直接访问公有静态成员变量
		所有对象共享类的静态成员变量
		可以通过对象名访问公有静态成员变量

	静态成员变量特性
		在定义时直接通过static关键字修饰
		静态成员变量需要在类外单独分配空间
		静态成员变量在程序内部位于全局数据区
	语法规则
		Type ClassName::Varname = value；

第25课小结
	类中可以通过static关键字定义静态成员变量
	静态成员变量隶属于类所有
	每个对象都可以访问静态成员变量
	静态成员变量在全局数据区分配空间
	静态成员变量的生命期为程序运行期

31，类的静态成员函数
	在C++中可以定义静态成员函数
		静态成员函数是类中特殊的成员函数
		静态成员函数属于整个类所有
		可以通过类名直接访问公有静态成员函数、
		可以通过对象名访问公有静态成员函数

								静态成员函数	vs    普通成员函数
		所有对象共享				Yes					Yes
		隐含this指针				No					Yes
		访问普通成员变量(函数)		No					Yes
		访问静态成员变量(函数)		Yes					Yes
		通过类名直接调用			Yes					No
		通过对象名直接调用			Yes					Yes

第26课小结
	静态成员函数是类中特殊的成员函数
	静态成员函数没有隐藏的this参数
	静态成员函数可以通过类名直接访问
	静态成员函数只能直接访问静态成员变量(函数)

32，二阶构造模式
	关于构造函数
		类的构造函数用于对象的初始化
		构造函数与类同名并且没有返回值
		构造函数在对象定义时自动被调用
	构造函数
		只提供自动初始化成员变量机会
		不能保证初始化逻辑一定成功
		执行return语句后构造函数立即结束
		构造函数能决定的只是对象的初始状态，而不是对象的诞生
	半成品对象的概念
		初始化操作不能按照预期完成而得到的对象
		半成品对象是合法的C++对象，也是bug的重要来源

	二阶构造
		在工程开发中的构造过程可分为
			资源无关的初始化操作
				不可能出现异常情况的操作
			需要使用系统资源的操作
				可能出现异常情况，如：内存申请，访问文件

								创建对象
									|
							资源无关初始操作	<---- 第一阶段构造
									|
							系统资源申请操作	<---- 第二阶段构造
									|
					False—————资源申请成功？—————True
					  |							  |
				删除半成品对象				   返回对象
					  |							  |
				  返回NULL						  |
				  	  |							  |
					  ————————————————————————————
					  				|
								   end

	二阶构造示例一
		class TwoPhaseCons
		{
		private:
			TwoPhaseCons(){		// 第一阶段构造函数
			}
			bool construct(){	// 第二阶段构造函数
				return true;
			}

		public:
			static TwoPhaseCons* NewInstance(); 	// 对象创建函数
		};

	二阶构造示例二
		TwoPhaseCons* TwoPhaseCons::NewInstance(){
			TwoPhaseCons* ret = new TwoPhaseCons();

			// 若第二阶段构造失败，返回NULL
			if( !(ret && ret->construct()) ){
				delete ret;
				ret = NULL;
			}

			return ret;
		}

第27课小结
	构造函数只能决定对象的初始化状态
	构造函数中初始化操作的失败不影响对象的诞生
	初始化不完全的半成品对象时bug的重要来源
	二阶构造人为的将初始化过程分为两部分
	二阶构造能够确保创建的对象都是完整初始化的

33，友元
	什么是友元？
		友元时C++中的一种关系
		友元关系发生在函数与类之间或者类与类之间
		友元关系时单项的，不能传递

	友元的用法
		在类中以friend关键字声明友元
		类的友元可以是其他类或者具体函数
		友元不是类的一部分
		友元不受类中访问级别的限制
		友元可以直接访问具体类的所有成员

	友元的语法
		在类中使用friend关键字对函数或类进行声明
			class Point
			{
				double x;
				double y;

				friend void func(Point& p);
			}
			void func(Point& p)
			{
			}
	
	友元的尴尬
		友元时为了兼顾C语言的高效而诞生的
		友元直接破坏了面向对象的封装性
		友元在实际产品中的高效是得不偿失的
		友元在现代软件工程中已经逐渐被遗弃
	注意事项
		友元关系不具备传递性
		类的友元可以是其它类的成员函数
		类的友元可以是整个完整的类
			所有成员函数都是友元

第28课小结
	友元时为了兼顾C语言的高效而诞生的
	友元直接破坏了面向对象的封装性
	友元关系不具备传递性
	类的友元可以是其它类的成员函数
	类的友元可以是整个完整的类

34，类中的函数重载
	函数重载回顾
		函数重载的本质为相互独立的不同函数
		C++中通过函数名和函数参数确定函数调用
		无法直接通过函数名得到重载函数的入口地址
		函数重载必然发生在同一个作用域中
	类中的重载
		类中的成员函数可以进行重载
			构造函数的重载
			普通成员函数的重载
			静态成员函数的重载
		问题
			全局函数，普通成员函数以及静态成员函数之间是否构成重载？
			全局函数和普通成员函数、静态成员函数作用域不同，不构成重载；
			普通成员函数和静态成员函数可以构成重载。
	万变不离其宗
		重载函数的本质为多个不同的函数
		函数名和参数列表时唯一的标识
		函数重载必然发生在同一个作用域中
	重载的意义
		通过函数名对函数功能进行提示
		通过参数列表对函数用法进行提示
		扩展系统中已经存在的函数功能

第29课小结
	类的成员函数之间可以进行重载
	重载必须发生在同一个作用域中
	全局函数和成员函数不能构成重载关系
	重载的意义在意扩展已经存在的功能

35，操作符重载的概念
	操作符重载
		C++中的重载能够扩展操作符的功能
		操作符的重载以函数的方式进行
		本质：
			用特殊形式的函数扩展操作符的功能
	通过operator关键字可以定义特殊的函数
	operator的本质是通过函数重载操作符
	语法：
		Type operator Sign(const Type p1, const Type p2)
		{
			Type ret;

			return ret;
		}
		Sign 为系统中预定义的操作符，如：+，-，×，/，等。

	可以将操作符重载函数定义为类的成员函数
		比全局操作符重载函数少一个参数(左操作数)
		不需要依赖友元就可以完成操作符重载
		编译器优先在成员函数中寻找操作符冲澡函数
			class Type
			{
			public:
				Type operator Sign(const Type& p)
				{
					Type ret;

					return ret;
				}
			};

第30课小结
	操作符重载是C++的强大特性之一
	操作符重载的本质时通过函数扩展操作符的功能
	operator关键字时实现操作符重载的关键
	操作符重载遵循相同的函数重载规则
	全局函数和成员函数都可以实现对操作符的重载

36，操作符重载
	注意事项
		C++规定赋值操作符(=)只能重载为成员函数
		操作符重载不能改变原操作符的优先级
		操作符重载不能改变操作数的个数
		操作符重载不应改变操作符的原有语义

第31课小结
	复数的概念可以通过自定义类实现
	复数中的运算操作可以通过操作符重载实现
	赋值操作符只能通过成员函数实现
	操作符重载的本质为函数定义

37，初探C++标准库
	C++标准库
		C++标准库并不是C++语言的一部分
		C++标准库是由类库和函数库组成的集合
		C++标准库中定义的类和对象都位于std命名空间中
		C++标准库的头文件都不带.h后缀
		C++标准库涵盖了C库的功能
	C++编译环境的组成
		—————————————————————————————————————————————
		|			 |				|				|
		| C++标准库  | C语言兼容库  | 编译器扩展库  |
		|			 |				|				|
		—————————————————————————————————————————————
		|					编译模块				|
		|	—————————————————	  ————————————————— |
		|	|C++标准语法模块|	  |C++扩展语法模块| |
		|	—————————————————     ————————————————— |
		—————————————————————————————————————————————

第32课小结
	C++标准库是由类库和函数库组成的集合
	C++标准库包含经典算法和数据结构的实现
	C++标准库涵盖了C库的功能
	C++标准库位于std命名空间中

38，C++中的字符串类
	历史遗留问题
		C语言不支持真正意义上的字符串
		C语言用字符数组和一组函数实现字符串操作
		C语言不支持自定义类型，因此无法获得字符串类型
	解决方案
		从C到C++的进化过程引入了自定义类型
		在C++中可以通过类完成字符串类型的定义
		C++标准库提供了string类型
			string类型支持字符串连接
			string直接支持字符串的大小比较
			string直接支持子串查找和提取
			string直接支持字符串的插入和替换

	字符串与数字的转换
		标准库中提供了相关的类对字符串和数字进行转换
		字符串流类(sstream)用于string的转换
			<sstream> - 相关头文件
			istringstream - 字符串输入流
			ostringstream - 字符串输出流

第33课小结
	应用开发中大多数的情况都在进行字符串处理
	C++中没有直接支持原声的字符串类型
	标准库中通过string类支持字符串的概念
	string类支持字符串和数字的相互转换
	string类的应用使得问题的求解变得简单

39，数组操作符的重载
	字符串类的兼容性
		string类最大限度的考虑了C字符串的兼容性
		可以按照使用C字符串的方式使用string对象

	被忽略的事实
		数组访问符是C/C++中的内置操作符
		数组访问符的原生意义是数组访问和指针运算
		a[n] <-> *(a + n) <-> *(n + a) <-> n[a]

	重载数组访问操作符
		数组访问操作符[]
			只能通过类的成员函数重载
			重载函数能且仅能使用一个参数
			可以定义不同参数的多个重载函数

第34课小结
	string类最大程度的兼容了C字符串的用法
	数组访问符的重载能够使得对象模拟数组的行为
	只能通过类的成员函数重载数组访问符
	重载函数能且仅能使用一个参数

40，函数对象分析
	函数对象
		使用具体的类对象取代函数
		该类的对象具备函数调用的行为
		构造函数指定具体数列项的起始位置
		多个对象相互独立的求解数列项

	函数调用操作符重载()
		只能通过类的成员函数重载
		可以定义不同参数的多个重载函数

第35课小结
	函数调用操作符()是可重载的
	函数调用操作符只能通过类的成员函数重载
	函数调用操作符可以定义不同参数的多个重载函数
	函数对象用于在工程中取代函数指针


41，经典问题分析
	关于赋值的疑问
		编译器为每个类默认重载了赋值操作符
		默认的赋值操作符仅完成浅拷贝
		当需要进行深拷贝时必须重载赋值操作符
		赋值操作符与拷贝构造函数有相同的存在意义
	一般性原则
		重载赋值操作符，必然需要实现深拷贝！！！

	编译器默认提供的函数
								class Test
								{
		class Test
		{						public:
					等价			Test();
		};							Test(const Test&);
									Test& operator = (const Test&);
									~Test();
								};
	
	关于string的疑问
	(1)问题分析
		s = "12345";			string m_cstr ---------> 12345
												 	---^ 0xFF112233
												 ---
		p = s.c_str();			const char* p ---


		s.append("abcd");		string m_cstr ---------> 12345abcd
		(可能会改变地址)								 0xFF445566

	string对象内部维护了一个指向数据的char*指针，这个指针可能在程序运行过程中发生改变

	(2)问题分析
		const char* p = "12345";
		string s = "";
		s.reserve(10);
		for(int i = 0; i < 5; i++)
		{
			s[i] = p[i];
		}
		cout << s << endl;	// print NULL
	for循环之前：
		string
		m_cstr ---------------> (10 bytes)
		m_length=0				0xFF112233

	for循环之后：
		string
		m_cstr ---------------> 12345+(5 bytes)
		m_length=0				0xFF112233

第36课小结
	在需要进行深拷贝的时候必须重载赋值操作符
	在赋值操作符和拷贝构造函数有同等重要的意义
	string类通过一个数据空间保存字符数据
	string类通过一个成员变量保存当前字符串的长度
	C++开发时尽量避开C语言中惯用的编程思想

42，智能指针分析
	内存泄露
		动态申请堆空间，用完后不归还
		C++语言中没有垃圾回收的机制
		指针无法控制所指堆空间的生命周期
	
	深度思考，我们需要什么
		需要一个特殊的指针
		指针生命周期结束时主动释放堆空间
		一片堆空间最多只能由一个指针标识
		杜绝指针运算和指针比较
	解决方案
		重载指针特征操作符( -> 和 *)
		只能通过类的成员函数重载
		重载函数不能使用参数
		只能定义一个重载函数

	智能指针的使用军规
		智能用来指向堆空间的对象或者变量

第37课小结
	指针特征操作符(-> 和 *)可以被重载
	重载指针特征符能够使用对象代替指针
	智能指针智能用于指向堆空间中的内存
	智能指针的意义在于最大程度的避免内存问题

43，逻辑操作符的陷阱
	逻辑操作符的原声语义
		操作数只有两种值(true和false)
		逻辑表达式不用完全计算就能确定最终值
		最终结果只能是true或者false

	问题的本质分析
		C++通过函数调用扩展操作符的功能
		进入函数体前必须完成所有的参数的计算
		函数参数的计算次序是不定的
		短路法则完全失效

	逻辑操作符重载后无法完全实现原生的语义

	一些有用的建议
		实际工程开发中避免重载逻辑操作符
		通过重载比较操作符代替逻辑操作符重载
		直接使用成员函数代替逻辑操作符重载
		使用全局函数对逻辑操作符进行重载

第38课小结
	C++从语法上支持逻辑操作符重载
	重载后的逻辑操作符不满足短路法则
	工程开发中不要重载逻辑操作符
	通过重载比较操作符替换逻辑操作符重载
	通过专用成员函数替换逻辑操作符重载

44，逗号操作符
	逗号操作符可以构成逗号表达式
		逗号表达式用于将多个子表达式连接为一个表达式
		逗号表达式的值为最后一个子表达式的值
		逗号表达式的前N-1个子表达式可以没有返回值
		逗号表达式按照从左向右的顺序计算每个子表达式的值
	
	重载逗号操作符
		在C++中重载逗号操作符是合法的
		使用全局函数对逗号操作符进行重载
		重载函数的参数必须有一个是类类型
		重载函数的返回值类型必须是引用
		class& operator , (const class& a, const class& b)
		{
			return const_cast<class&>(b);
		}

	问题的本质分析
		C++通过函数调用扩展操作符的功能
		进入函数体前必须完成所有参数的计算
		函数参数的计算次序是不定的
		重载后无法严格从左向右计算

第39课小结
	逗号表达式从左向右顺序计算每个子表达式的值
	逗号表达式的值为最后一个子表达式的值
	操作符重载无法完全实现逗号操作符的原生意义
	工程开发中不要重载逗号操作符

45，前置操作符和后置操作符
	意想不到的事实
		现代编译器产品会对代码进行优化
		优化使得最终的二进制程序更加高效
		优化后的二进制程序丢失了C/C++的原声语义
		不可能从编译后的二进制程序还原C/C++程序

	++操作符可以被重载
		全局函数和成员函数均可以进行重载
		重载前置++操作符不需要额外的参数
		重载后置++操作符需要一个int类型的占位参数

	前置和后置的真正区别
		对于基础类型的变量
			前置++的效率与后置++的效率基本相同
			根据项目编码规范进行选择
		对于类类型的对象
			前置++的效率高于后置++
			尽量使用前置++操作符提高程序效率

第40课小结
	编译优化使得最终的可执行程序更加高效
	前置++和后置++都可以被重载
	++操作符的重载必须符合其原生语义
	对于基础类型，前置++和后置++的效率几乎相同
	对于类类型，前置++的效率高于后置++

46，类型转换函数上
	再论类型转换
		标准数据类型之间会进行隐式的类型安全转换
		转换规则如下
			char ->	
			  |		int -> unsigned int -> long -> unsigned long -> float -> double 
			short ->

	再论构造函数
		构造函数可以定义不同类型的参数
		参数满足下列条件时称为转换构造函数
			有且只有一个参数
			参数是基本类型
			参数是其它类类型

	示例
		编译器会尽力尝试让源代码通过编译
			Test t;
			t = 100;
		"100这个立即数默认为int类型，怎么可能赋值给t对象呢！现在就报错吗？不急，我看看有没有转换构造函数！
		OK，发现Test类中定义了Test(int i)，可以进行转换，默认等价于：t = Test(100);"

	编译器的行为
		编译器尽力尝试的结果是隐式类型转换
		隐式类型转换
			会让程序以意想不到的方式进行工作
			是工程中bug的重要来源
		工程中通过explicit关键字杜绝编译器的转换尝试
		转换构造函数被explicit修饰时只能进行显示转换
			转换方式
				static_cast<ClassName>(value);
				ClassName(value);
				(ClassName)value;	// 不推荐

第41课小结
	转换构造函数只有一个参数
	转换构造函数的参数类型是其他类型
	转换构造函数在类型转换时被调用
	隐式类型转换时工程中bug的重要来源
	explicit关键字用于杜绝隐式类型转换

47，类型转换函数下
	类型转换函数
		C++类中可以定义类型转换函数
		类型转换函数用于将类对象转换为其他类型
		语法规则
			operator Type ()
			{
				Type ret;
				// ...
				return ret;
			}

	类型转换函数
		与转换构造函数具有同等的地位
		使得编译器有能力将对象转化为其他类型
		编译器能够隐式的使用类型转换函数
	示例
		编译器会尽力尝试让源代码通过编译
			Test t(1);
			int i = t;
		"t这个对象为Test类型，怎么可能用于初始化int类型的变量呢！现在就报错吗？不急，我看看有没有类型转换函数！
		OK，发现Test类中定义了operator int()，可以进行转换。"

	类型转换函数
		无法抑制隐式的类型转换函数调用
		类型转换函数可能与转换构造函数冲突
		工程中以Type to Type()的公有成员函数代替类型转换函数

第42课小结
	C++类中可以定义类型转换函数
	类型转换函数用于将类对象转换为其他类型
	类型转换函数与转换构造函数具有相同的地位
	工程中以Type to Type()的公有成员函数代替类型转换函数

48，继承的概念和意义
	类之间的组合关系
		组合关系的特点
			将其它类的对象作为当前类的成员
			当前类的对象与成员对象的生命期相同
			成员对象在用法上与普通对象完全一致

	惊艳的继承
		面向对象中的继承指类之间的父子关系
			子类拥有父类的所有属性和行为
			子类就是一种特殊的父类
			子类对象可以当做父类对象的使用
			子类中可以添加父类没有的方法和属性
		C++中通过下面的方式描述继承关系
			class Parent
			{
				int mv;
			public:
				void method(){};
			};
			class child : public Parent
			{
			};
		重要规则
			子类就是一个特殊的父类
			子类对象可以直接初始化父类对象
			子类对象可以直接赋值给父类对象

	继承的意义
		继承是C++中代码复用的重要手段。通过继承，可以直接获得父类的所有功能，
		并且可以在子类中重写已有功能，或者新添功能。

第43课小结
	继承时面向对象中类之间的一种关系
	子类拥有父类的所有属性和行为
	子类对象可以当做父类对象使用
	子类中可以添加父类没有的方法和属性
	继承时面向对象中代码复用的重要手段

49，继承中的访问级别
	面向对象中的访问级别不只是public和private
	可以定义protected访问级别
	关键字protected的意义
		修饰的成员不能被外界直接访问
		修饰的成员可以被子类直接访问

第44课小结
	面向对象中的访问级别不只是public和private
	protected修饰的成员不能被外界所访问
	protected使得子类能够访问父类的成员
	protected关键字是为了继承而专门设计的
	没有protected关键字就无法完成真正意义上的代码复用

50，不同的继承方式
	C++中支持三种不同的继承方式
		public继承
			父类成员在子类中保持原有的访问级别
		private继承
			父类成员在子类中变为私有成员
		protected继承
			父类成员中的公有成员变为保护成员，其它成员保持不变
	C++中的默认继承方式为private

	一般而言，C++工程项目中只使用public继承
	C++的派生语言只支持一种继承方式（public继承）
	protected和private继承带来的复杂性远大于实用性

第45课小结
	C++中支持3种不同的继承方式
	继承方式直接影响父类成员在子类中的访问属性
	一般而言，工程中只使用public的继承方式
	C++的派生语言中只支持public继承方式

51，继承中的构造与析构
	子类对象的构造
		子类中可以定义构造函数
		子类构造函数
			必须对继承而来的成员进行初始化
				直接通过初始化列表或者赋值的方式进行初始
				调用父类构造函数进行初始化
		父类构造函数在子类中的调用方式
			默认调用
				适用于无参构造函数和使用默认参数的构造函数
			显示调用
				通过初始化列表进行调用
				适用于所有父类构造函数
		父类构造函数的调用
			class Child : public Parent
			{
			public:
				Child()	/* 隐式调用 */
				{
					cout << "Child()" << endl;
				}
				Child(string s) /* 显示调用 */
						: Parent("Parameter to Parent")
				{
					cout << "Child() : " << s << endl;
				}
			};
		构造规则
			子类对象在创建时会首先调用父类的构造函数
			先执行父类构造函数在执行子类的构造函数
			父类构造函数可以被隐式调用或者显示调用
		对象创建时构造函数的调用顺序
			调用父类的构造函数
			调用成员变量的构造函数
			调用类自身的构造函数
	
	子类对象的析构
		析构函数的调用顺序与构造函数相反
			执行自身的析构函数
			执行成员变量的析构函数
			执行父类的析构函数

第46课小结
	子类对象在创建时需要调用父类构造函数进行初始化
	先执行父类构造函数然后执行成员的构造函数
	父类构造函数显示调用需要在初始化列表中进行
	子类对象在销毁时需要调用父类析构函数进行清理
	析构顺序与构造顺序对称相反

52，父子间的冲突
	子类可以定义父类中的同名成员
	子类中的成员将隐藏父类中的同名成员
	父类中的同名成员依然存在于子类中
	通过作用域分辨符(::)访问父类中的同名成员

	再论重载
		类中的成员函数可以进行重载
			重载函数的本质为多个不同的函数
			函数名和参数列表是唯一的标识
			函数重载必须发生在同一个作用域中
	
	子类中的函数将隐藏父类中的同名函数
	子类无法重载父类中的成员函数
	使用作用域分辨符访问父类中的同名函数
	子类可以定义父类中完全相同的成员函数

第47课小结
	子类可以定义父类中的同名函数
	子类中的成员将将隐藏父类中的同名成员
	子类和父类中的函数不能构成重载关系
	子类可以定义父类中完全相同的成员函数
	使用作用域分辨符访问父类中的同名成员

53，同名覆盖引发的问题
	父子间的赋值兼容
		子类对象可以当做父类对象使用(兼容性)
			子类对象可以直接赋值给父类对象
			子类对象可以直接初始化父类对象
			父类指针可以直接指向子类对象
			父类引用可以直接引用子类对象
		当使用父类指针(引用)指向子类对象时
			子类对象退化为父类对象
			只能访问父类中定义的成员
			可以直接访问被子类覆盖的同名成员

	特殊的同名函数
		子类中可以重定义父类中已经存在的成员函数
		这种重定义发生在继承中，叫做函数重写
		函数重写是同名覆盖的一种特殊情况

第48课小结
	子类对象可以当做父类对象使用(赋值兼容)
	父类指针可以正确的指向子类对象
	父类引用可以正确的代表子类对象
	子类中可以重写父类中的成员函数

54，多态的概念和意义
	函数重写回顾
		父类中被重写的函数依然会继承给子类
		子类中重写的函数将覆盖父类中的函数
		通过作用域分辨符::可以访问到父类中的函数
			Child c;
			Parent* p = &c;

			c.Parent::print();	// 从父类中继承
			c.print();			// 在子类中重写
			p->print();			// 父类中定义

	面向对象中期望的行为
		根据实际的对象类型判断如何调用重写函数
		父类指针(引用)指向
			父类对象则调用父类中定义的函数
			子类对象则调用子类中定义的重写函数
	面对对象中多态的概念
		根据实际的对象类型决定函数调用的具体目标
		同样的调用语句在实际运行时有多种不同的表现形态
	C++语言直接支持多态的概念
		通过使用virtual关键字对多态进行支持
		被virtual声明的函数被重写后具有多态特性
		被virtual声明的函数叫做虚函数
	多态的意义
		在程序运行过程中展现出动态的特性
		函数重写必须多态实现，否则没有意义
		多态时面向对象组件化程序设计的基础特性

	理论中的概念
		静态联编
			在程序的编译几件就能确定具体的函数调用
				如：函数重载
		动态联编
			在程序实际运行后才能确定具体的函数调用
				如：函数重写

第49课小结
	函数重写只能发生在父类与子类之间
	根据实际对象的类型确定调用的具体函数
	virtual关键字时C++中支持多态的唯一方式
	被重写的虚函数可表现出多态的特性

55，C++对象模型分析-上
	回归本质
		class是一种特殊的struct
			在内存中class依旧看做变量的集合
			class与struct遵循相同的内存对齐规则
			class中的成员函数与成员变量是分开存放的
				每个对象有独立的成员变量
				所有对象共享类中的成员函数
	运行时的对象退化为结构体的形式
		所有成员变量在内存中依次排布
		成员变量间可能存在内存间隙
		可以通过内存地址直接访问成员变量
		访问权限关键字在运行时失效

	类中的成员函数位于代码段中
	调用成员函数时对象地址作为参数隐式传递
	成员函数通过对象地址访问成员变量
	C++语法规则隐藏了对象地址的传递过程

第50课小结
	C++中的类对象在内存布局上与结构体相同
	成员变量和成员函数在内存布局中分开存放
	访问权限关键字在运行时失效
	调用成员函数时对象地址作为参数隐式传递

56，C++对象模型分析-下
	继承对象模型
		在C++编译器的内部类可以理解为结构体
		子类是由父类成员叠加子类新成员得到的
	
	C++多态的实现原理
		当类中声明虚函数时，编译器会在类中生成一个虚函数表
		虚函数表是一个存储成员函数地址的数据结构
		虚函数表是由编译器自动生成维护的
		virtual成员函数会被编译器放入虚函数表中
		存在虚函数时，每个对象中都有一个指向虚函数表的指针

第51课小结
	继承的本质就是父子间成员变量的叠加
	C++中的多态时通过虚函数表实现的
	虚函数表是由编译器自动生成与维护的
	虚函数的调用效率低于普通成员函数

57，C++中的抽象类和接口
	面向对象中的抽象类
		可用于表示现实世界中的抽象概念
		是一种只能定义类型，而不能产生对象的类
		只能被继承并重写相关函数
		直接特征是相关函数没有完整的实现
	
	抽象类与纯虚函数
		C++语言中没有抽象类的概念
		C++中通过纯虚函数实现抽象类
		纯虚函数是指只定义原型的成员函数
		一个C++类中存在纯虚函数就成为了抽象类
	纯虚函数的语法规则
		class Shape
		{
		public:
			virtual double area() = 0;
		};
		"=0"用于告诉编译器当前声明纯虚函数，因此不需要定义函数体。
	
	抽象类只能用作父类被继承
	子类必须实现纯虚函数的具体功能
	纯虚函数被实现后成为虚函数
	如果子类没有实现纯虚函数，则子类成为抽象类

	满足下面条件的C++类则称为接口
		类中没有定义任何的成员变量
		所有的成员函数都是公有的
		所有的成员函数都是纯虚函数
		接口是一种特殊的抽象类

第52课小结
	抽象类用于描述现实世界中的抽象概念
	抽象类只能被继承不能创建对象
	C++中没有抽象类的概念
	C++中通过纯虚函数实现抽象类
	类中只存在纯虚函数的称为接口
	接口是一种特殊的抽象类

58，被遗弃的多重继承-上
	C++中的多重继承
		C++支持编写多重继承的代码
			一个子类可以拥有多个父类
			子类拥有所有父类的成员变量
			子类继承所有父类的成员函数
			子类对象可以当做任意父类对象使用
		语法规则
			class Derived : public BaseClassA,
							public BaseClassB,
							public BaseClassC
			{
			};
		多重继承和单继承本质上是一样的

	多重继承的问题一
		通过多重继承得到的对象可能拥有“不同的地址”！！！
		解决方案：无
			Derived d(1, 2, 3);
			BaseClassA* pa = &d;
			BaseClassB* pb = &d;
				pa--->	int ma;
						int mb;  <----pb
						int mc;

	多重继承的问题二
		当多重继承关系出现闭合时将产生数据冗余的问题！！！
		解决方案：虚继承
			class People {};
			class Teacher : virtual public People {};
			class Student : virtual public People {};
			class Doctor : public Teacher, public Student
			{};
		虚继承能够解决数据冗余的问题
		中间层父类不在关心顶层父类的初始化
		最终子类必须直接调用顶层父类的构造函数
		问题：
			当架构设计中需要继承时，无法确定使用直接继承还是虚继承！！

第53课小结
	C++支持多重继承的变成方式
	多重继承容易带来问题
		可能出现“同一个对象的地址不同”的情况
		虚继承可以解决数据冗余的问题
		虚继承使得架构设计可能出现问题

59, 被遗弃的多重继承－下
	多重继承的问题三：
		多重继承可能产生多个虚函数表
			BaseA	   BaseB
				Derived
	  VTable A   vptr1
				 vptr2  VTable B
		需要进行强制类型转换时，C++中推荐使用新式类型转换关键字！！
		解决方案：dynamic_cast
			Derived d;
			BaseA* pa = &d;
			BaseB* pb = &d;
			BaseB* pbb = (BaseB*)pa;
				pa ---> vptr1; <--- pbb
						vptr2; <--- pb

	正确的使用多重继承
		工程开发中的”多重继承“方式：
			单继承某个类 + 实现(多个)接口

	一些有用的建议
		先继承自一个父类，然后实现多个接口
		父类中提供equal()成员函数
		equal()成员函数用于判断指针是否指向当前对象
		与多继承相关的强制转换用dynamic_cast完成

第５４课小结
	多继承中可能出现多个虚函数表指针
	与多重继承相关的强制转换用dynamic_cast完成
	工程开发中采用“单继承多接口”的方式使用多继承
	父类提供成员函数用于判断是否指向当前对象


60，经典问题分析四
	关于动态内存分配
		new关键字与malloc函数的区别
			malloc是由C库提供的函数
			new以具体类型为单位进行内存分配
			malloc以字节为单位进行内存分配
			new在申请内存空间时可进行初始化
			malloc仅根据需要申请定量的内存空间
		new和malloc的区别
			new在所有C++编译器中都支持
			malloc在某些系统开发中是不能调用
			new能够触发构造函数的调用
			malloc仅分配需要的内存空间
			对象的创建只能使用new
			malloc不适合面向对象开发
		delete和free的区别
			delete在所有C++编译器中都支持
			free在某些系统开发中是不能调用
			delete能够触发析构函数调用
			free仅归还之前分配的内存空间
			对象的销毁只能使用delete
			free不适合面向对象开发

	关于虚函数
		构造函数是否可以成为虚函数？
		析构函数是否可以成为虚函数？

		构造函数不可能成为虚函数
			在构造函数执行结束之后，虚函数表指针才会被正确的初始化
		析构函数可以成为虚函数
			建议在设计类时将析构函数声明为虚函数

		构造函数中不可能发生多态行为
			在构造函数执行时，虚函数表指针未被正确初始化
		析构函数中不可能发生多态行为
			在析构函数执行时，虚函数表指针已经被销毁
		构造函数和析构函数中不可能发生多态行为，只能调用当前类中定义的版本！！！

	关于继承中的强制类型转换
		dynamic_cast是与继承相关的类型转换关键字
		dynamic_cast要求相关的类中必须有虚函数
		用于有直接或者间接继承关系的指针(引用)之间
			指针：
				转换成功：得到目标类型的指针
				转换失败：得到一个空指针
			引用：
				转换成功：得到目标类型的引用
				转换失败：得到一个异常操作信息
		编译器会检查dynamic_cast的使用是否正确
		类型转换的结果只可能在运行阶段才能得到

第55课小结
	new / delete会触发构造函数或者析构函数调用
	构造函数不能成为虚函数
	析构函数可以成为虚函数
	构造函数和析构函数中都无法产生多态行为
	dynamic_cast是与继承相关的专用转换关键字

61，函数模板的概念和意义
	交换变量的方法
		定义宏代码块
			优点：代码复用，适合所有的类型
			缺点：编译器不知道宏的存在，缺少类型检查
		定义函数
			优点：真正的函数调用，编译器对类型进行检查
			缺点：根据类型重复定义函数，无法复用代码
	
	C++中泛型编程
		函数模板
			一种特殊的函数可用不同类型进行调用
			看起来和普通函数很类似，区别是参数可被参数化
				template<typename T>
				void Swap(T& a, T& b)
				{
					T t = a;
					a = b;
					b = t;
				}
			函数模板的语法规则
				template 关键字用于声明开始进行泛型编程
				typename 关键字用于声明泛指类型
		函数模板的使用
			自动类型推导调用
			具体类型显示调用
				int a = 0;
				int b = 1;
				Swap(a, b);		// 自动推导

				float c = 2;
				float d = 3;
				Swap<float>(c, d);	// 显示调用

第56课小结
	函数模板是泛型编程在C++中应用方式之一
	函数模板能够根据实参对参数类型进行推导
	函数模板支持显示的指定参数类型
	函数模板是C++中重要的代码复用方式

62，深入理解函数模板
	函数模板深入理解
		编译器从函数模板通过具体类型参数不同的函数
		编译器对函数模板进行两次编译
			对模板代码本身进行编译
			对参数替换后的代码进行编译
		注意事项
			函数模板本身不允许隐式类型转换
				自动推导类型时，必须严格匹配
				显示类型指定时，能够进行隐式类型转换
	
	多参数函数模板
		函数模板可以定义任意多个不同的类型参数
			template
			< typename T1, typename T2, typename T3>
			T1 add(T2 a, T3 b)
			{
				return static_cast<T1>(a + b);
			}
			int r = add<int, float, double>(0.5, 0.8);
		对于多参数函数模板
			无法自动推导返回值类型
			可以从左向右部分指定类型参数
				工程中将返回值参数作为第一个类型参数

	当函数重载遇到函数模板会发生什么?
	重载函数模板
		函数模板可以像普通函数一样被重载
			C++编译器优先考虑普通函数
			如果函数模板可以产生一个更好的匹配，那么选择模板
			可以通过空模板实参列表限定编译器只匹配模板
				int r1 = Max(1, 2);
				double r2 = Max<>(0.5, 0.8);

第57课小结
	函数模板通过具体类型产生不同的函数
	函数模板可以定义任意多个不同的类型参数
	函数模板中的返回值类型必须显示指定
	函数模板可以像普通函数一样被重载


