C到C++的升级

1，register关键字
	C++编译器有自己的优化方式
		C语言中无法获取register变量的地址
		C++中可以取得register变量的地址(优化方式是当去地址时，register关键字对变量的修饰失效)

2，在C语言中，重复定义多个同名的全局变量是合法的，多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。
	在C++中，不允许定义多个同名的全局变量

3, struct关键字的加强
	C语言中的struct定义了一组变量的集合，struct定义的标识符并不是一种新的类型；
	C++中的struct用于定义一个全新的类型

4，函数返回值及参数
   在C语言中
	int f()表示返回值为int，接受任意参数的函数
	f(void)表示返回值为int的无参函数
   在C++中
	int f()和int f(void)具有相同的意义
	表示返回值为int的无参函数
注：C++中所有的标识符都必须显示的声明类型，C语言中的默认类型在C++中是不合法的

第2课小结：
	C++更强调实用性，可以在任意的地方声明变量
	C++中的register只是一个兼容的作用
	C++编译器能够更好的进行优化
	C++中的任意标识符都必须显示的指明类型

5，const关键字
	C语言中的const：(1)修饰的变量是只读的，本质还是变量；(2)修饰的局部变量在栈上分配空间；
					(3)修饰的全局变量在只读存储区分配空间；(4)只在编译期有用，在运行期无用；
					(5)const修饰的变量不是真的常亮，它只是告诉编译器该变量不能出现在赋值符号的左边。
	C++中的const：C++在C的基础上对const进行了优化处理，当碰见const声明时在符号表中放入常量；
				  编译过程中若发现使用常量则以符号表中的值替换；
				  编译过程中若发现下述情况则给对应的常量分配存储空间，对const常量使用了extern，对const常量使用&操作符；
				  注意：C++编译器虽然可能为const常量分配空间，但不会使用其存储空间中的值。
	小结：C语言中的const变量是只读变量，会分配存储空间；
		  C++中的const变量可能分配存储空间：1)当const变量为全局，并且需要在其它文件中使用；2)当使用&操作符对const常量取地址。
  C++中const与宏定义
  	C++中的const常量类似于宏定义
		const int a = 5; 类似 #define a 5
	C++中的const常量早与宏定义不同
		const常量是由编译器处理
		编译器对const常量进行类型检查和作用域检查
		宏定义由预处理器处理，单纯的文本替换

第3课小结：
	与C语言不通，C++中的const不是只读变量
	C++中的const是一个真正意义上的常量
	C++编译器可能会为const常量分配空间(兼容C语言)
	C++完全兼容C语言中const常量的语法特性

6, bool类型
	C++中的bool类型
		C++在C语言的基本类型系统之上增加了bool
		C++中的bool可取的值只有true和false
		理论上bool只占用一个字节
		C++编译器会将非0值转换为true，0值转换为false

7，三目运算符
	C++对三目运算符进行了升级，可以作为左值，这句代码在C++中是正确的：(val_1 < val_2 ? val_1 : val_2) = 3;
	但是在C语言中是不可以作为左值的。

	C语言中的三目运算符返回的是变量值
		不能作为左值使用
	C++中的三目运算符可直接返回变量本身
		既可作为右值使用，又可作为左值使用
		注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用。
	C++对三目运算符做了什么？
		当三目运算符的可能返回都是变量时，返回的是变量的引用；
		当三目运算符的可能返回中有常量时，返回的是值。

8，C++中的引用
	变量名
		变量是一段实际连续存储空间的别名
		程序中通过变量来申请并命名存储空间
		通过变量名的名字可使用存储空间

	C++中新增了引用的概念
		引用可以看做一个已定义变量的别名
		引用的语法：Type& name = val;
		注意：普通引用在定义时必须用同类型的变量进行初始化

第4课小结：
	bool类型是C++新增加的基础类型
	bool类型的值只可能是true和false
	C++中的三目运算符可作为左值使用
	C++中的引用可以看做变量的别名来使用
	三目运算符的可能返回都是变量时，返回的是引用

9，const引用
	(1)在C++中可以声明const引用，const Type& name = val;
	const引用让变量拥有只读属性

	(2)当使用常量对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名
		const int&b = 1;	// OK
		int* p = (int *)&b;
		b = 5;				// error, 只读变量
		*p = 5;				// OK，修改变量的值
		结论：使用常量对const引用初始化后将生成一个只读变量！！！
		
  引用的本质
  	引用在C++中的内部实现是一个指针常量
		Type& name;		<--->		Type* const name;

		void f(int& a)				void f(int* const a)
		{				<--->		{
			a = 5;						*a = 5;
		}							}
	注意：C++编译器在编译过程中使用指针常量作为引用的内部实现，因此引用所占的空间大小与指针相同。
		  从使用的角度，引用只是一个别名，C++为了实用性而隐藏了引用的存储空间这一细节。

  引用的意义
  	C++中的引用旨在大多数的情况下代替指针
		功能性：可以满足多数需要使用指针的场合
		安全性：可以避开由于指针操作不当而带来的内存错误
		操作性：简单易用，又不失功能强大

第5课小结：
	引用作为变量别名而存在旨在代替指针
	const引用可以使得变量具有只读属性
	引用在编译器内部使用指针常量实现
	引用的最终本质为指针
	引用可以尽可能的避开内存错误(例如不要返回局部变量的引用)

10，内联函数
	C++中推荐使用内联函数代替宏代码片段
	C++中使用inline关键字声明内联函数
	内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求

	C++编译器可以将一个函数进行内联编译
	被C++编译器内联编译的函数叫做内联函数
	C++编译器直接将函数体插入到函数调用的地方
	内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)

	内联函数具有普通函数的特征(参数检查，返回类型等)
	函数的内敛请求可能被编译器拒绝
	函数被内联后，函数体直接扩展到调用的地方
	(宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程，因此可能出现副作用)

	现代C++编译器能够进行编译优化，一些函数即使没有inline声明，也可能被内联编译
	一些现代C++编译器提供了扩展语法，能够对函数进行强制内联，如：
		g++：  __attribute__((always_inline))属性
		MSVC： __forceinline

	注意事项：
	C++中inline内联编译的限制
		不能存在任何形式的循环语句
		不能存在过多的条件判断语句
		函数体不能过于庞大
		不能对函数进行取址操作
		函数内联声明必须在调用语句之前

第6课小结：
	C++中可以通过inline声明内联函数
	编译器直接将内联函数体扩展到函数调用的地方
	inline只是一种请求，编译器不一定允许这种请求
	内联函数省去了函数调用时压栈，跳转和返回的开销


